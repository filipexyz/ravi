#!/usr/bin/env bun
/**
 * Generate internal plugins registry
 *
 * Scans src/plugins/internal/ and generates a TypeScript file with
 * the plugin content embedded (SKILL.md, plugin.json, etc).
 * This allows plugins to be bundled with the compiled code.
 *
 * Run before build: bun run gen:plugins
 */

import { readdirSync, readFileSync, writeFileSync, existsSync } from "node:fs";
import { join } from "node:path";

const PLUGINS_DIR = join(import.meta.dir, "../src/plugins/internal");
const OUTPUT_FILE = join(import.meta.dir, "../src/plugins/internal-registry.ts");

interface PluginFile {
  path: string; // relative path within plugin
  content: string;
}

interface PluginData {
  name: string;
  manifest: Record<string, unknown>;
  files: PluginFile[];
}

/**
 * Recursively collect all files in a directory
 */
function collectFiles(dir: string, basePath = ""): PluginFile[] {
  const files: PluginFile[] = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relativePath = basePath ? `${basePath}/${entry.name}` : entry.name;

    if (entry.isDirectory()) {
      files.push(...collectFiles(fullPath, relativePath));
    } else {
      // Only include text files we care about
      if (
        entry.name.endsWith(".md") ||
        entry.name.endsWith(".json") ||
        entry.name.endsWith(".txt")
      ) {
        files.push({
          path: relativePath,
          content: readFileSync(fullPath, "utf-8"),
        });
      }
    }
  }

  return files;
}

/**
 * Scan plugins directory and collect all plugin data
 */
function scanPlugins(): PluginData[] {
  if (!existsSync(PLUGINS_DIR)) {
    console.log("No internal plugins directory found");
    return [];
  }

  const plugins: PluginData[] = [];
  const entries = readdirSync(PLUGINS_DIR, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const pluginPath = join(PLUGINS_DIR, entry.name);
    const manifestPath = join(pluginPath, ".claude-plugin", "plugin.json");

    if (!existsSync(manifestPath)) {
      console.log(`  Skipping ${entry.name} (no manifest)`);
      continue;
    }

    const manifest = JSON.parse(readFileSync(manifestPath, "utf-8"));
    const files = collectFiles(pluginPath);

    plugins.push({
      name: entry.name,
      manifest,
      files,
    });

    console.log(`  Found plugin: ${entry.name} (${files.length} files)`);
  }

  return plugins;
}

/**
 * Generate TypeScript code
 */
function generateCode(plugins: PluginData[]): string {
  const pluginsJson = JSON.stringify(plugins, null, 2);

  return `/**
 * Internal Plugins Registry (auto-generated)
 *
 * DO NOT EDIT - This file is generated by scripts/gen-plugins.ts
 * Run: bun run gen:plugins
 *
 * Contains embedded plugin data for: ${plugins.map(p => p.name).join(", ")}
 */

export interface PluginFile {
  path: string;
  content: string;
}

export interface InternalPlugin {
  name: string;
  manifest: Record<string, unknown>;
  files: PluginFile[];
}

/** Embedded internal plugins */
export const INTERNAL_PLUGINS: InternalPlugin[] = ${pluginsJson};

/** Get internal plugin by name */
export function getInternalPlugin(name: string): InternalPlugin | undefined {
  return INTERNAL_PLUGINS.find(p => p.name === name);
}

/** Get all internal plugin names */
export function getInternalPluginNames(): string[] {
  return INTERNAL_PLUGINS.map(p => p.name);
}
`;
}

// Main
console.log("Generating internal plugins registry...");
const plugins = scanPlugins();
const code = generateCode(plugins);
writeFileSync(OUTPUT_FILE, code);
console.log(`Generated ${OUTPUT_FILE} with ${plugins.length} plugins`);
