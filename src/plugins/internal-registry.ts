/**
 * Internal Plugins Registry (auto-generated)
 *
 * DO NOT EDIT - This file is generated by scripts/gen-plugins.ts
 * Run: bun run gen:plugins
 *
 * Contains embedded plugin data for: ravi-system, ravi-dev
 */

export interface PluginFile {
  path: string;
  content: string;
}

export interface InternalPlugin {
  name: string;
  manifest: Record<string, unknown>;
  files: PluginFile[];
}

/** Embedded internal plugins */
export const INTERNAL_PLUGINS: InternalPlugin[] = [
  {
    "name": "ravi-system",
    "manifest": {
      "name": "ravi-system",
      "version": "1.0.0",
      "description": "Ravi system management skills - agents, contacts, triggers, routes, and more"
    },
    "files": [
      {
        "path": ".claude-plugin/plugin.json",
        "content": "{\n  \"name\": \"ravi-system\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Ravi system management skills - agents, contacts, triggers, routes, and more\"\n}\n"
      },
      {
        "path": "skills/settings/SKILL.md",
        "content": "---\nname: settings-manager\ndescription: |\n  Gerencia configurações globais do Ravi. Use quando o usuário quiser:\n  - Ver ou alterar configurações do sistema\n  - Definir agent default\n  - Configurar DM scope padrão\n  - Ver todas as settings disponíveis\n---\n\n# Settings Manager\n\nConfigurações globais do sistema Ravi.\n\n## Comandos\n\n### Listar todas\n```bash\nravi settings list\n```\n\n### Ver valor\n```bash\nravi settings get <key>\n```\n\n### Definir valor\n```bash\nravi settings set <key> <value>\n```\n\n### Remover\n```bash\nravi settings delete <key>\n```\n\n## Settings Disponíveis\n\n| Key | Descrição | Valores |\n|-----|-----------|---------|\n| `defaultAgent` | Agent padrão quando nenhuma rota casa | ID do agent |\n| `defaultDmScope` | Escopo padrão de DMs | main, per-peer, per-channel-peer, per-account-channel-peer |\n| `defaultTimezone` | Fuso horário padrão | America/Sao_Paulo, etc |\n\n## ⚠️ Settings Depreciadas (use `ravi instances`)\n\nAs settings `account.*` foram migradas para a tabela `instances`. **Não use mais estas keys:**\n\n| Key depreciada | Substituta |\n|----------------|-----------|\n| `account.<name>.agent` | `ravi instances set <name> agent <agent>` |\n| `account.<name>.instanceId` | `ravi instances set <name> instanceId <id>` |\n| `account.<name>.dmPolicy` | `ravi instances set <name> dmPolicy <policy>` |\n| `account.<name>.groupPolicy` | `ravi instances set <name> groupPolicy <policy>` |\n\nA migração acontece automaticamente na primeira inicialização do daemon.\n\n## Exemplos\n\nDefinir agent default:\n```bash\nravi settings set defaultAgent main\n```\n\nConfigurar timezone:\n```bash\nravi settings set defaultTimezone America/Sao_Paulo\n```\n\nConfigurar policy por instância (forma correta):\n```bash\nravi instances set main dmPolicy pairing\nravi instances set vendas groupPolicy allowlist\n```\n"
      },
      {
        "path": "skills/video/SKILL.md",
        "content": "---\nname: video\ndescription: |\n  Analisa vídeos do YouTube ou arquivos locais via Gemini. Use quando o usuário quiser:\n  - Assistir/analisar um vídeo do YouTube\n  - Transcrever um vídeo\n  - Entender o conteúdo de um vídeo\n  - Extrair informações de um vídeo\n---\n\n# Video Analysis\n\nAnalisa vídeos usando a API do Gemini. Suporta URLs do YouTube (públicos) e arquivos locais.\n\n## Como usar\n\n### Analisar vídeo do YouTube\n```bash\nravi video analyze \"https://www.youtube.com/watch?v=VIDEO_ID\"\n```\n\n### Analisar com output específico\n```bash\nravi video analyze \"https://www.youtube.com/watch?v=VIDEO_ID\" -o ./video-analysis.md\n```\n\n### Analisar com prompt custom\n```bash\nravi video analyze \"https://www.youtube.com/watch?v=VIDEO_ID\" -p \"Foque nos argumentos técnicos apresentados\"\n```\n\n### Analisar arquivo local\n```bash\nravi video analyze /path/to/video.mp4\n```\n\n## O que é extraído\n\nO comando salva um `.md` no diretório atual com:\n\n- **Título** do vídeo\n- **Resumo** completo do conteúdo\n- **Tópicos** principais abordados\n- **Transcrição** de toda a fala\n- **Descrição visual** timestamped (o que acontece visualmente)\n\n## Fluxo recomendado\n\n1. Rode `ravi video analyze <url>` — gera o `.md`\n2. Leia o arquivo gerado com a tool Read\n3. Interprete e responda ao usuário baseado no conteúdo\n\n## Limitações\n\n- Só vídeos **públicos** do YouTube (não funciona com privados/não listados)\n- Vídeos muito longos (>1h) podem demorar ou exceder limites de token\n- Requer `GEMINI_API_KEY` configurada no `~/.ravi/.env`\n- Formatos locais suportados: mp4, mpeg, mov, avi, flv, webm, wmv, 3gpp\n\n## Configuração\n\nA variável `GEMINI_API_KEY` precisa estar no `~/.ravi/.env`. O modelo padrão é `gemini-2.5-flash`, configurável via `GEMINI_VIDEO_MODEL`.\n"
      },
      {
        "path": "skills/copilot/SKILL.md",
        "content": "---\nname: copilot\ndescription: |\n  Gerencia a ponte bidirecional entre Ravi e sessões do Claude Code. Use quando o usuário quiser:\n  - Enviar mensagens pra sessões do Claude Code via mailbox\n  - Listar times ativos do Claude Code\n  - Configurar hooks e triggers pro copilot\n  - Entender como a integração CC ↔ Ravi funciona\n---\n\n# Copilot — Claude Code Bridge\n\nVocê gerencia a ponte bidirecional entre Ravi e sessões do Claude Code (CC).\n\n## Como Funciona\n\n```\nCC → Ravi:  Hooks globais (~/.claude/settings.json) → ravi-copilot.sh → nats pub ravi.copilot.*\nRavi → CC:  ravi copilot send <team> \"msg\" → ~/.claude/teams/{team}/inboxes/team-lead.json\n```\n\n1. **Global hooks** em `~/.claude/settings.json` disparam em cada evento do CC\n2. **Hook script** `~/.claude/hooks/ravi-copilot.sh` lê o JSON, wrapa num envelope e publica no NATS\n3. **Ravi triggers** assinam os tópicos `ravi.copilot.*` e reagem\n4. **Mailbox injection** — Ravi escreve no inbox JSON do CC pra comunicar de volta (CC precisa estar em team mode)\n\n## Comandos\n\n### Enviar mensagem pra sessão CC\n```bash\nravi copilot send <teamName> \"mensagem\"\nravi copilot send <teamName> \"mensagem\" --from jarvis\nravi copilot send <teamName> \"mensagem\" --summary \"Alerta\" --color red\n```\n\n### Listar times do CC\n```bash\nravi copilot teams\n```\n\n### Descobrir teams no disco\n```bash\nls ~/.claude/teams/\ncat ~/.claude/teams/{name}/config.json\n```\n\n## NATS Topics\n\n| Topic | Evento CC | Descrição |\n|---|---|---|\n| `ravi.copilot.session.start` | SessionStart | Sessão CC aberta |\n| `ravi.copilot.session.end` | SessionEnd | Sessão CC fechada |\n| `ravi.copilot.prompt` | UserPromptSubmit | Usuário enviou prompt |\n| `ravi.copilot.tool.pre` | PreToolUse | Tool prestes a executar |\n| `ravi.copilot.tool.post` | PostToolUse | Tool executou com sucesso |\n| `ravi.copilot.tool.fail` | PostToolUseFailure | Tool falhou |\n| `ravi.copilot.stop` | Stop | Claude terminou de gerar |\n| `ravi.copilot.subagent.start` | SubagentStart | Subagente criado |\n| `ravi.copilot.subagent.stop` | SubagentStop | Subagente terminou |\n| `ravi.copilot.notification` | Notification | Notificação do CC |\n| `ravi.copilot.teammate.idle` | TeammateIdle | Teammate ficou idle |\n| `ravi.copilot.config.change` | ConfigChange | Config do CC mudou |\n| `ravi.copilot.compact.pre` | PreCompact | Compactação de contexto |\n| `ravi.copilot.task.completed` | TaskCompleted | Task delegada concluída |\n\n### Envelope do payload\n\n```json\n{\n  \"session_id\": \"abc-123\",\n  \"session_type\": \"main\",\n  \"cwd\": \"/path/to/project\",\n  \"event\": \"PostToolUse\",\n  \"timestamp\": \"2026-02-25T17:30:00Z\",\n  \"data\": { ...payload original do CC... }\n}\n```\n\n## Exemplos de Triggers\n\n### Alertar em falha de tool\n```bash\nravi triggers add \"CC Tool Failure\" \\\n  --topic \"ravi.copilot.tool.fail\" \\\n  --message \"Uma ferramenta falhou no Claude Code. Analise o erro e avise o Luis se for crítico.\" \\\n  --agent main --cooldown 30s --session isolated\n```\n\n### Monitorar sessões novas\n```bash\nravi triggers add \"CC Session Start\" \\\n  --topic \"ravi.copilot.session.start\" \\\n  --message \"Nova sessão do Claude Code iniciada. Registre o CWD e session_id.\" \\\n  --agent main --cooldown 10s --session isolated\n```\n\n### Monitorar comandos Bash perigosos\n```bash\nravi triggers add \"CC Bash Monitor\" \\\n  --topic \"ravi.copilot.tool.post\" \\\n  --message \"Tool executada no CC. Se for Bash com comando perigoso (rm -rf, push --force, DROP TABLE), alerte imediatamente. Senão @@SILENT@@.\" \\\n  --agent main --cooldown 5s --session isolated\n```\n\n### Notificar fim de sessão\n```bash\nravi triggers add \"CC Session End\" \\\n  --topic \"ravi.copilot.session.end\" \\\n  --message \"Sessão do Claude Code terminou. Atualize TASKS.md se relevante. @@SILENT@@ se nada a fazer.\" \\\n  --agent main --cooldown 10s --session isolated\n```\n\n## Setup\n\n1. Verificar `nats` CLI: `nats --version` (senão: `brew install nats-io/nats-tools/nats`)\n2. Daemon rodando: `ravi daemon status`\n3. Hook executável: `ls -la ~/.claude/hooks/ravi-copilot.sh`\n4. Hooks registrados: `cat ~/.claude/settings.json | grep -c \"ravi-copilot.sh\"` (deve mostrar 14)\n5. Testar: `nats sub \"ravi.copilot.>\" --server nats://127.0.0.1:4222`\n6. Abrir sessão CC → eventos devem aparecer no subscriber\n\n## Arquivos Chave\n\n| Arquivo | Função |\n|---|---|\n| `~/.claude/settings.json` | Hooks globais do CC |\n| `~/.claude/hooks/ravi-copilot.sh` | Script que publica no NATS |\n| `~/.claude/teams/{name}/config.json` | Config do team CC |\n| `~/.claude/teams/{name}/inboxes/*.json` | Mailbox dos membros |\n\n## Notas\n\n- CC precisa estar em **team mode** pra receber mensagens do Ravi (inbox poller só roda com team ativo)\n- NATS port: `4222` (default), override via `RAVI_NATS_URL` env var\n- Hook script requer `jq` e `nats` no PATH — falha silenciosa se ausentes\n- Publishes em background (`&`) — nunca bloqueia o CC\n- Triggers têm anti-loop: eventos de sessões trigger são ignorados\n"
      },
      {
        "path": "skills/triggers/SKILL.md",
        "content": "---\nname: trigger-manager\ndescription: |\n  Gerencia triggers de eventos do sistema Ravi. Use quando o usuário quiser:\n  - Criar, listar, ver ou deletar triggers\n  - Configurar reações automáticas a eventos (CLI, SDK tools, mensagens)\n  - Ativar/desativar triggers existentes\n  - Testar triggers manualmente\n---\n\n# Trigger Manager\n\nVocê gerencia os triggers de eventos do Ravi. Triggers são reações automáticas que disparam quando eventos específicos acontecem no sistema.\n\n## Comandos Disponíveis\n\n### Listar triggers\n```bash\nravi triggers list\n```\n\n### Ver detalhes de um trigger\n```bash\nravi triggers show <id>\n```\n\n### Criar trigger\n```bash\nravi triggers add \"<nome>\" --topic \"<pattern>\" --message \"<prompt>\"\n```\n\nOpções:\n- `--agent <id>` - Agent que processa (default: agent padrão)\n- `--cooldown <duration>` - Intervalo mínimo entre disparos (ex: 5s, 1m, 30s)\n- `--session <main|isolated>` - Sessão (default: isolated)\n\n### Ativar/Desativar\n```bash\nravi triggers enable <id>\nravi triggers disable <id>\n```\n\n### Configurar propriedades\n```bash\nravi triggers set <id> <key> <value>\n```\nKeys: name, message, topic, agent, session, cooldown, filter\n\n### Testar trigger\n```bash\nravi triggers test <id>\n```\n\n### Deletar\n```bash\nravi triggers rm <id>\n```\n\n## Tópicos Disponíveis\n\nPatterns usam wildcards (`*`):\n\n### Inbound e Canais\n\n| Pattern | Descrição |\n|---------|-----------|\n| `whatsapp.*.inbound` | Mensagens WhatsApp recebidas |\n| `matrix.*.inbound` | Mensagens Matrix recebidas |\n| `ravi.inbound.reaction` | Reações recebidas (emoji) |\n| `ravi.inbound.reply` | Replies a mensagens do bot |\n| `ravi.inbound.pollVote` | Votos em enquetes |\n\n### Contatos e Aprovações\n\n| Pattern | Descrição |\n|---------|-----------|\n| `ravi.contacts.pending` | Novo contato/grupo pendente de aprovação |\n| `ravi.approval.request` | Pedido de aprovação cascading |\n| `ravi.approval.response` | Resposta de aprovação |\n\n### Agent e Tools\n\n| Pattern | Descrição |\n|---------|-----------|\n| `ravi.*.cli.{group}.{command}` | Execuções de CLI tools (ex: `ravi.*.cli.contacts.add`) |\n| `ravi.*.tool` | Execuções de SDK tools (Bash, Read, etc) |\n\n### Outbound\n\n| Pattern | Descrição |\n|---------|-----------|\n| `ravi.outbound.deliver` | Mensagens enviadas para canais |\n| `ravi.outbound.receipt` | Read receipts enviados |\n| `ravi.outbound.refresh` | Refresh de filas outbound |\n\n**Bloqueados (anti-loop):** Triggers em tópicos `ravi.session.*` são rejeitados para evitar loops internos.\n\n## Filtros\n\nTriggers suportam filtros opcionais que impedem o disparo quando o evento não casa com a expressão:\n\n```bash\nravi triggers add \"...\" --filter 'data.cwd startsWith \"/Users/luis/ravi\"'\nravi triggers set <id> filter 'data.cwd != \"/Users/luis/Dev/fm\"'\nravi triggers set <id> filter 'data.permission_mode == \"bypassPermissions\"'\n```\n\n**Sintaxe:** `data.<path> <operador> \"<valor>\"`\n\nOperadores: `==`, `!=`, `startsWith`, `endsWith`, `includes`\n\nFiltro inválido = fail open (trigger dispara mesmo assim, log de warning).\n\n## Template Variables\n\nMensagens de triggers suportam `{{variável}}` resolvidos com os dados do evento:\n\n```\ndata.cwd startsWith \"/Users/luis/ravi\"\n```\n\n| Variável | Descrição |\n|----------|-----------|\n| `{{topic}}` | Tópico NATS que disparou o trigger |\n| `{{data.cwd}}` | Diretório de trabalho da sessão |\n| `{{data.last_assistant_message}}` | Última mensagem do CC (truncada em 300 chars) |\n| `{{data.prompt}}` | Prompt enviado pelo usuário (UserPromptSubmit) |\n| `{{data.<campo>}}` | Qualquer campo do payload do evento |\n\nVariáveis não resolvidas ficam como estão (`{{data.inexistente}}`).\n\n**Exemplo de message com templates:**\n```\nCC parou em {{data.cwd}}. Última msg: \"{{data.last_assistant_message}}\". Informe o Luis se relevante, senão @@SILENT@@.\n```\n\n## Exemplos\n\nCriar trigger para notificar quando lead é qualificado:\n```bash\nravi triggers add \"Lead Qualificado\" --topic \"ravi.*.cli.outbound.qualify\" --message \"Analise a qualificação e notifique o grupo\"\n```\n\nCriar trigger para monitorar erros:\n```bash\nravi triggers add \"Agent Error\" --topic \"ravi.*.tool\" --message \"Analise o erro e sugira correção\" --cooldown 1m\n```\n\n## Relação com NATS\n\nTriggers reagem a eventos do **NATS** (o barramento de eventos do Ravi). Para entender os tópicos disponíveis, consulte a skill `events`.\n\n- **NATS** = barramento de eventos (pub/sub direto)\n- **triggers** = reações automáticas a eventos NATS\n"
      },
      {
        "path": "skills/contacts/SKILL.md",
        "content": "---\nname: contacts-manager\ndescription: |\n  Gerencia contatos do sistema Ravi. Use quando o usuário quiser:\n  - Listar, adicionar, aprovar ou bloquear contatos\n  - Ver contatos pendentes de aprovação\n  - Configurar agent ou modo de resposta por contato\n  - Adicionar/remover tags ou buscar por tags\n  - Ver detalhes de um contato específico\n---\n\n# Contacts Manager\n\nVocê gerencia os contatos do Ravi. Contatos controlam quem pode interagir com o sistema e como são roteados.\n\n## Status de Contatos\n\n| Status | Descrição |\n|--------|-----------|\n| `allowed` | Pode interagir normalmente |\n| `pending` | Aguardando aprovação |\n| `blocked` | Bloqueado, mensagens ignoradas |\n| `discovered` | Descoberto mas não aprovado |\n\n## Comandos Disponíveis\n\n### Listar contatos\n```bash\nravi contacts list\n```\n\n### Ver pendentes\n```bash\nravi contacts pending\n```\n\n### Adicionar contato\n```bash\nravi contacts add <phone> [nome]\n```\n\n### Aprovar pendente\n```bash\nravi contacts approve <phone> [agent] [mode]\n```\n- `agent` - Agent ID para rotear (opcional)\n- `mode` - `auto` (responde sempre) ou `mention` (só quando mencionado)\n\n### Bloquear/Permitir\n```bash\nravi contacts block <phone>\nravi contacts allow <phone>\n```\n\n### Remover\n```bash\nravi contacts remove <phone>\n```\n\n### Ver detalhes\n```bash\nravi contacts check <phone>\n```\n\n### Configurar propriedades\n```bash\nravi contacts set <phone> <key> <value>\n```\n\nKeys disponíveis:\n- `agent` - Agent ID para rotear\n- `mode` - `auto` ou `mention`\n- `email` - Email do contato\n- `name` - Nome do contato\n- `tags` - Array JSON: `'[\"lead\",\"vip\"]'`\n- `notes` - Objeto JSON: `'{\"empresa\":\"Acme\"}'`\n- `opt-out` - `true` ou `false`\n\n## Tags\n\n### Adicionar tag\n```bash\nravi contacts tag <phone> <tag>\n```\n\n### Remover tag\n```bash\nravi contacts untag <phone> <tag>\n```\n\n### Buscar por tag\n```bash\nravi contacts find <tag> --tag\n```\n\n### Buscar por texto\n```bash\nravi contacts find <query>\n```\n\n## Exemplos\n\nAprovar contato e rotear para agent específico:\n```bash\nravi contacts approve 5511999999999 vendas auto\n```\n\nAdicionar tags a um contato:\n```bash\nravi contacts tag 5511999999999 lead\nravi contacts tag 5511999999999 interessado\n```\n\nConfigurar notas com contexto:\n```bash\nravi contacts set 5511999999999 notes '{\"empresa\":\"TechCorp\",\"cargo\":\"CTO\"}'\n```\n\n## Relação com Routes\n\nContacts e Routes trabalham juntos no roteamento:\n\n- **Contacts** podem ter `agent_id` direto — isso tem prioridade sobre routes\n- **Routes** definem regras por padrão (prefixo, grupo, catch-all) como fallback\n- `ravi contacts list` mostra o agent e modo de resposta de cada contato\n- Para gerenciar rotas: use a skill `ravi-system:routes`\n- Ordem de resolução: contact.agent_id > route match > accountId > default agent\n"
      },
      {
        "path": "skills/cross/SKILL.md",
        "content": "---\nname: cross-manager\ndescription: |\n  DEPRECADO — use os comandos de sessions:\n  - ravi sessions send <session> \"mensagem\"\n  - ravi sessions ask <session> \"pergunta\" \"sender\"\n  - ravi sessions answer <session> \"resposta\" \"sender\"\n  - ravi sessions execute <session> \"tarefa\"\n  - ravi sessions inform <session> \"info\"\n---\n\n# Cross Manager (DEPRECADO)\n\nOs comandos `ravi cross send` e `ravi cross list` foram migrados para `ravi sessions`.\n\n## Migração\n\n| Antes | Agora |\n|-------|-------|\n| `ravi cross send <target> relay \"msg\"` | `ravi sessions send <session> \"msg\"` |\n| `ravi cross send <target> inform \"msg\"` | `ravi sessions inform <session> \"msg\"` |\n| `ravi cross send <target> execute \"msg\"` | `ravi sessions execute <session> \"msg\"` |\n| `ravi cross send <target> ask \"msg\" \"sender\"` | `ravi sessions ask <session> \"msg\" \"sender\"` |\n| `ravi cross send <target> answer \"msg\" \"sender\"` | `ravi sessions answer <session> \"msg\" \"sender\"` |\n| `ravi cross list` | `ravi sessions list` |\n\n## Notas\n\n- Targets agora usam **session names** (ex: `main`, `e2-filipe-e2`) em vez de session keys\n- Source/context são resolvidos automaticamente da sessão\n- Use `--channel` e `--to` para override explícito de routing\n"
      },
      {
        "path": "skills/agents/SKILL.md",
        "content": "---\nname: agents-manager\ndescription: |\n  Gerencia agents do sistema Ravi. Use quando o usuário quiser:\n  - Criar, configurar ou deletar agents\n  - Gerenciar permissões de tools (whitelist/bypass)\n  - Configurar permissões de Bash (allowlist/denylist)\n  - Ver ou resetar sessões de agents\n  - Configurar debounce de mensagens\n  - Entender como rotear mensagens pra um agent\n---\n\n# Agents Manager\n\nAgents são instâncias do Claude com configurações específicas (diretório, tools, permissões). Cada agent tem seu workspace, sessões independentes e pode atender canais/contatos diferentes.\n\n**Importante:** Criar ou modificar agents **não requer restart** do daemon. Tudo atualiza em tempo real.\n\n## Fluxo Completo: Criar um Agent e Colocar pra Funcionar\n\n### 1. Criar o agent\n\n```bash\nravi agents create <id> <cwd>\n```\n\nO `cwd` é o diretório onde fica o `CLAUDE.md` do agent (suas instruções). Crie o diretório e o `CLAUDE.md` antes.\n\n### 2. Rotear mensagens pro agent\n\nExistem duas formas de rotear:\n\n**Por rota (padrão de grupo/contato):**\n```bash\nravi instances routes add <instance> <pattern> <agent>\n```\n\nPatterns suportados:\n- `group:120363425628305127` — grupo específico\n- `lid:178035101794451` — contato específico (por lid)\n- `5511*` — todos com DDD 11\n- `*` — catch-all\n\n**Por contato (assignment direto):**\n```bash\nravi contacts approve <phone> <agent>\n# ou\nravi contacts set <phone> agent <agent>\n```\n\n### 3. Ativar em grupo WhatsApp\n\nGrupos novos precisam ser **aprovados** antes de funcionar.\n\n**Instrua o usuário a:**\n1. Criar um grupo no WhatsApp e adicionar o bot\n2. Mandar uma mensagem qualquer no grupo (isso faz o grupo aparecer como **pending**)\n\n**Depois, VOCÊ (o agent) deve executar:**\n```bash\nravi contacts pending                            # Checar pendentes — o grupo aparece aqui\nravi contacts approve <group-id> <agent>                       # Aprovar e associar ao agent\nravi instances routes add main <group-id> <agent>              # Criar rota pro grupo\n```\n\n**IMPORTANTE:** Não peça o ID do grupo pro usuário. Rode `ravi contacts pending` pra descobrir o ID automaticamente. O usuário já mandou a mensagem — o grupo já está lá.\n\nTudo atualiza em tempo real. **Não precisa reiniciar o daemon.**\n\n### Como novos contatos/grupos aparecem?\n\nQuando alguém novo manda mensagem (ou o bot é adicionado a um grupo novo), o contato/grupo aparece como **pending** automaticamente. Nenhuma mensagem é processada até ser aprovado.\n\n```bash\nravi contacts pending     # Ver contatos/grupos pendentes\n```\n\nPra aprovar e rotear:\n```bash\nravi contacts approve <phone> <agent>   # Aprova e associa ao agent\nravi contacts approve <phone>           # Aprova sem associar (usa rota ou default)\nravi contacts block <phone>             # Bloqueia\n```\n\n### Prioridade de roteamento\n\nQuando uma mensagem chega, o sistema resolve o agent nesta ordem:\n\n1. **Contato tem agent?** → usa o agent do contato\n2. **Tem rota que casa?** → usa o agent da rota (prioridade maior primeiro)\n3. **Account ID casa com agent?** → usa (Matrix multi-account)\n4. **Nenhum match** → usa o agent default (geralmente `main`)\n\n## Comandos Disponíveis\n\n### Listar agents\n```bash\nravi agents list\n```\n\n### Ver detalhes\n```bash\nravi agents show <id>\n```\n\n### Criar agent\n```bash\nravi agents create <id> <cwd>\n```\n\n### Deletar agent\n```bash\nravi agents delete <id>\n```\n\n### Configurar propriedades\n```bash\nravi agents set <id> <key> <value>\n```\n\nKeys:\n- `name` — Nome do agent\n- `cwd` — Diretório de trabalho\n- `model` — Modelo (claude-opus-4-6, claude-sonnet-4-5-20250929, etc)\n- `dmScope` — Escopo de sessão DM:\n  - `main` — Todas as DMs numa sessão só\n  - `per-peer` — Uma sessão por contato (default)\n  - `per-channel-peer` — Por canal + contato\n  - `per-account-channel-peer` — Isolamento total\n- `systemPromptAppend` — Texto adicional no system prompt\n- `matrixAccount` — Conta Matrix associada\n\n## Permissões (REBAC)\n\nPermissões de tools e executáveis são gerenciadas via REBAC:\n\n```bash\n# Ver permissões de um agent\nravi permissions list --subject agent:<id>\n\n# Configurar permissões\nravi permissions init agent:<id> full-access     # Tudo liberado\nravi permissions init agent:<id> sdk-tools       # SDK tools padrão\nravi permissions init agent:<id> safe-executables # Executáveis seguros\n\n# Grants individuais\nravi permissions grant agent:<id> use tool:Bash\nravi permissions grant agent:<id> execute executable:git\n```\n\nVer skill `permissions-manager` para documentação completa.\n\n## Debounce de Mensagens\n\nAgrupa mensagens rápidas antes de processar:\n\n```bash\nravi agents debounce <id> <ms>   # Definir (ex: 2000 = 2s)\nravi agents debounce <id> 0      # Desabilitar\nravi agents debounce <id>        # Ver atual\n```\n\n## Sessões\n\n### Ver sessões\n```bash\nravi agents session <id>\n```\n\n### Resetar sessão\n```bash\nravi agents reset <id>              # Sessão principal\nravi agents reset <id> <sessionKey> # Sessão específica\nravi agents reset <id> all          # Todas as sessões\n```\n\n## Interação\n\n### Enviar prompt\n```bash\nravi agents run <id> \"prompt\"\n```\n\n### Chat interativo\n```bash\nravi agents chat <id>\n```\n\n## Receita Completa: Agent Pessoal com Grupo WhatsApp\n\nAgents pessoais são agents dedicados a um aspecto da vida do usuário (comunicação, journaling, estratégia, etc). Cada um tem seu grupo WhatsApp exclusivo.\n\n**Conceito importante:** O agent já nasce dentro do WhatsApp. Ele não precisa de nenhuma tool pra enviar mensagens — toda resposta dele já chega automaticamente no WhatsApp. Ele deve saber disso no CLAUDE.md.\n\n### Passo a passo\n\n#### 1. Criar diretório e CLAUDE.md\n\n```bash\nmkdir -p ~/ravi/<agent-id>\n```\n\nEscreva o `CLAUDE.md` com a identidade e instruções do agent. Estrutura recomendada:\n\n```markdown\n# <Nome do Agent>\n\n## Quem Você É\n- Papel, personalidade, tom de voz\n- O que você faz e o que NÃO faz\n\n## Contexto\n- Você já está conversando pelo WhatsApp com o usuário\n- Toda mensagem que você envia chega diretamente no WhatsApp\n- Você NÃO precisa de nenhuma tool pra enviar mensagens\n\n## Como Funciona\n- Metodologia, frameworks, abordagem\n- Exemplos de interação\n\n## Regras\n- Limites, boundaries, o que evitar\n```\n\n**Dicas pro CLAUDE.md:**\n- Dê personalidade — agents genéricos são chatos\n- Seja específico sobre o que o agent faz e não faz\n- Inclua que ele já está no WhatsApp (não precisa de tool pra mensagem)\n- Adapte o tom pro contexto (coach é diferente de diário é diferente de estrategista)\n\n#### 2. Criar o agent no sistema\n\n```bash\nravi agents create <agent-id> ~/ravi/<agent-id>\n```\n\n#### 3. Criar grupo WhatsApp dedicado\n\nO usuário cria um grupo no WhatsApp (ex: \"Vida - Comunicação\") e adiciona o bot. Ao enviar a primeira mensagem no grupo, o contato aparece automaticamente como **pending**.\n\n#### 4. Aprovar e rotear o grupo\n\n**Não peça o ID do grupo pro usuário.** Rode o CLI pra descobrir:\n\n```bash\n# Ver grupos/contatos pendentes\nravi contacts pending\n\n# Aprovar o grupo\nravi contacts approve <group-id>\n\n# Criar rota pro agent\nravi instances routes add main <group-id> <agent-id>\n```\n\nO `group-id` tem formato `group:120363406060070449`.\n\n#### 5. Pronto!\n\nO agent já está respondendo no grupo. Não precisa reiniciar o daemon.\n\n### Exemplo real: Agent de comunicação\n\n```bash\n# 1. Criar diretório\nmkdir -p ~/ravi/comm\n\n# 2. Escrever CLAUDE.md (com identidade de coach de comunicação)\n\n# 3. Criar agent\nravi agents create comm ~/ravi/comm\n\n# 4. Usuário cria grupo \"Vida - Comunicação\" no WhatsApp e manda msg\n\n# 5. Aprovar e rotear\nravi contacts pending                          # Encontra group:120363406060070449\nravi contacts approve group:120363406060070449  # Aprova\nravi instances routes add main group:120363406060070449 comm   # Roteia pro comm\n```\n\n## Exemplos Práticos\n\n### Criar agent pra atendimento\n\n```bash\n# 1. Criar diretório e CLAUDE.md\nmkdir -p ~/ravi/atendimento\n# (crie o CLAUDE.md com as instruções do agent)\n\n# 2. Criar agent\nravi agents create atendimento ~/ravi/atendimento\n\n# 3. Rotear grupo pro agent\nravi instances routes add main group:120363425628305127 atendimento\n\n# 4. Configurar permissões (via REBAC)\nravi permissions init agent:atendimento sdk-tools       # SDK tools padrão\nravi permissions init agent:atendimento safe-executables # Executáveis seguros\nravi permissions grant agent:atendimento use tool:Bash   # Liberar Bash\n```\n\n### Aprovar contato e associar a agent\n\n```bash\n# Ver pendentes\nravi contacts pending\n\n# Aprovar e associar\nravi contacts approve 5511999999999 atendimento\n\n# Ou aprovar com modo \"mention\" (só responde quando mencionado)\nravi contacts approve 5511999999999 atendimento mention\n```\n\n### Configurar rota com prioridade\n\n```bash\n# Rota específica (prioridade alta)\nravi instances routes add main group:123456789 vendas\nravi instances routes set main group:123456789 priority 10\n\n# Rota catch-all (prioridade baixa)\nravi instances routes add main \"*\" main\n```\n"
      },
      {
        "path": "skills/permissions/SKILL.md",
        "content": "---\nname: permissions-manager\ndescription: |\n  Gerencia permissões REBAC do sistema Ravi. Use quando o usuário quiser:\n  - Ver, conceder ou revocar permissões de agents\n  - Verificar se um agent tem permissão pra algo\n  - Sincronizar permissões com configs dos agents\n  - Entender o modelo de permissões\n---\n\n# Permissions Manager (REBAC)\n\nPermissões no Ravi são relações: **(sujeito) tem (relação) sobre (objeto)**.\n\nExemplo: `(agent:dev) access (session:dev-*)` — o agent dev pode acessar sessões que começam com \"dev-\".\n\n## IMPORTANTE: Object Types\n\nO object type no grant DEVE corresponder ao que o engine checa. Se errar o type, a permissão não funciona.\n\n**Regra:** Comandos CLI usam `group:<nome-do-grupo>`. Sessões usam `session:<pattern>`. Sistema usa `system:*`.\n\n## Referência Rápida de Grants\n\n### Acesso a grupos de comandos CLI (scope: admin)\n\nO scope `admin` no decorator `@Group` checa `execute` no object type `group`:\n\n```bash\n# Formato: ravi permissions grant agent:<id> execute group:<grupo>\n\n# Daemon (restart, status, logs)\nravi permissions grant agent:dev execute group:daemon\n\n# Agents (create, delete, set, tools, bash)\nravi permissions grant agent:dev execute group:agents\n\n# Sessions (list, send, ask, read, reset, delete...)\nravi permissions grant agent:dev execute group:sessions\n\n# Contacts (list, add, approve, block, tags)\nravi permissions grant agent:dev execute group:contacts\n\n# Routes (add, remove, set, list)\nravi permissions grant agent:dev execute group:routes\n\n# Settings (list, get, set)\nravi permissions grant agent:dev execute group:settings\n\n# Channels (status, start, stop, restart)\nravi permissions grant agent:dev execute group:channels\n\n# Heartbeat (set, enable, disable, trigger)\nravi permissions grant agent:dev execute group:heartbeat\n\n# Matrix (add, remove, send, rooms)\nravi permissions grant agent:dev execute group:matrix\n\n# WhatsApp groups (create, members, invite)\nravi permissions grant agent:dev execute group:whatsapp.group\n\n# Service (install, uninstall, start, stop)\nravi permissions grant agent:dev execute group:service\n```\n\n**Subcomando específico** — dá acesso a só um comando dentro do grupo:\n```bash\n# Só restart, não status/logs\nravi permissions grant agent:dev execute group:daemon_restart\n\n# Só list, não create/delete\nravi permissions grant agent:dev execute group:agents_list\n```\n\n### Superadmin (scope: superadmin)\n\n```bash\n# Acesso total — permissions, e todos os outros grupos\nravi permissions grant agent:dev admin system:*\n```\n\n### Sessões (inline scope checks)\n\n```bash\n# Acessar sessões (ler, enviar)\nravi permissions grant agent:dev access session:dev-*\n\n# Modificar sessões (reset, delete, rename, set-model)\nravi permissions grant agent:dev modify session:dev-*\n```\n\n### Contatos (scope: writeContacts)\n\n```bash\n# Criar/aprovar/bloquear contatos\nravi permissions grant agent:dev write_contacts system:*\n\n# Ler contatos das próprias sessões\nravi permissions grant agent:dev read_own_contacts system:*\n\n# Ler contatos com tag específica\nravi permissions grant agent:dev read_tagged_contacts system:leads\n```\n\n### Grupos que NÃO precisam de grant (scope: open/resource)\n\nEstes funcionam pra qualquer agent sem grant:\n- `sessions` (open) — mas comandos de modificação checam session scope inline\n- `media` (open)\n- `react` (open)\n- `tools` (open)\n- `transcribe` (open)\n- `video` (open)\n- `whatsapp.dm` (open)\n- `cron` (resource) — checa ownership do recurso\n- `triggers` (resource) — checa ownership do recurso\n- `outbound` (resource) — checa ownership do recurso\n\n## ERROS COMUNS\n\n❌ **ERRADO** — usar `system:daemon` pra liberar o grupo daemon:\n```bash\nravi permissions grant agent:dev execute system:daemon\n```\nIsso não funciona! O engine checa `group:daemon`, não `system:daemon`.\n\n✅ **CERTO:**\n```bash\nravi permissions grant agent:dev execute group:daemon\n```\n\n❌ **ERRADO** — usar `admin` pra dar acesso a um grupo específico:\n```bash\nravi permissions grant agent:dev admin group:daemon\n```\n`admin` só funciona com `system:*` (superadmin total).\n\n✅ **CERTO** — usar `execute`:\n```bash\nravi permissions grant agent:dev execute group:daemon\n```\n\n❌ **ERRADO** — confundir `group` com `executable`:\n```bash\nravi permissions grant agent:dev execute group:*   # libera comandos CLI, NÃO executáveis\n```\n\n✅ **CERTO** — object types separados:\n```bash\nravi permissions grant agent:dev execute group:*        # comandos CLI\nravi permissions grant agent:dev execute executable:*   # executáveis do sistema\n```\n\n❌ **ERRADO** — relação errada pra executáveis:\n```bash\nravi permissions grant agent:dev use executable:git   # \"use\" é pra SDK tools\n```\n\n✅ **CERTO:**\n```bash\nravi permissions grant agent:dev execute executable:git  # executáveis usam \"execute\"\nravi permissions grant agent:dev use tool:Bash           # SDK tools usam \"use\"\n```\n\n### SDK Tools (use tool:*)\n\nControla quais SDK tools um agent pode usar:\n\n```bash\n# Permitir tool específica\nravi permissions grant agent:dev use tool:Bash\nravi permissions grant agent:dev use tool:Read\n\n# Permitir TODAS as tools (bypass)\nravi permissions grant agent:dev use tool:*\n\n# Verificar\nravi permissions check agent:dev use tool:Bash\n```\n\nSDK tools disponíveis: `Bash`, `Read`, `Edit`, `Write`, `Glob`, `Grep`, `WebFetch`, `WebSearch`, `Task`, `TaskOutput`, `TaskStop`, `TodoWrite`, `NotebookEdit`, `AskUserQuestion`, `EnterPlanMode`, `ExitPlanMode`, `EnterWorktree`, `Skill`, `TeamCreate`, `TeamDelete`, `SendMessage`, `LSP`, `ToolSearch`.\n\n### Tool Groups (use toolgroup:*)\n\nEm vez de dar grant tool por tool, use **tool groups** pra conceder acesso a um conjunto de tools de uma vez:\n\n```bash\n# Conceder um grupo\nravi permissions grant agent:dev use toolgroup:read-only\n\n# Conceder todos os grupos\nravi permissions init agent:dev tool-groups\n\n# Revocar um grupo\nravi permissions revoke agent:dev use toolgroup:read-only\n\n# Verificar — o check resolve transparentemente\nravi permissions check agent:dev use tool:Read   # ✓ se tem toolgroup:read-only\n```\n\n**Grupos disponíveis:**\n\n| Grupo | Tools |\n|---|---|\n| `read-only` | Read, Glob, Grep, WebFetch, WebSearch, LSP, ToolSearch |\n| `write` | Edit, Write, NotebookEdit |\n| `execute` | Bash, Task, TaskOutput, TaskStop |\n| `plan` | EnterPlanMode, ExitPlanMode, AskUserQuestion, TodoWrite |\n| `teams` | TeamCreate, TeamDelete, SendMessage |\n| `navigate` | EnterWorktree, Skill |\n\n**Como funciona:** Quando o engine checa `can(agent:X, use, tool, Read)`, se não encontra grant direto pra `tool:Read`, verifica se o agent tem algum `toolgroup` que inclui `Read`. Se sim, permite.\n\n**Combina com grants individuais:** Um agent pode ter `toolgroup:read-only` + `tool:Bash` — os dois se somam.\n\n### Executáveis do sistema (execute executable:*)\n\nControla quais binários do sistema um agent pode rodar via Bash:\n\n```bash\n# Permitir executável específico\nravi permissions grant agent:dev execute executable:git\nravi permissions grant agent:dev execute executable:node\nravi permissions grant agent:dev execute executable:ravi\n\n# Permitir TODOS os executáveis (bypass)\nravi permissions grant agent:dev execute executable:*\n\n# Verificar\nravi permissions check agent:dev execute executable:git\n```\n\n### Templates (atalhos)\n\n```bash\n# SDK tools padrão (uma relação por tool)\nravi permissions init agent:dev sdk-tools\n\n# Todas as SDK tools (wildcard)\nravi permissions init agent:dev all-tools\n\n# Todos os tool groups (read-only, write, execute, plan, teams, navigate)\nravi permissions init agent:dev tool-groups\n\n# Executáveis seguros (git, node, bun, ravi, etc.)\nravi permissions init agent:dev safe-executables\n\n# Tudo: todas tools + todos executáveis\nravi permissions init agent:dev full-access\n```\n\n## Comandos\n\n### Listar permissões\n```bash\n# Todas\nravi permissions list\n\n# De um agent específico\nravi permissions list --subject agent:dev\n\n# De um tipo de objeto\nravi permissions list --object group:contacts\n\n# Por relação\nravi permissions list --relation access\n\n# Por source\nravi permissions list --source manual\n```\n\n### Conceder permissão\n```bash\nravi permissions grant <sujeito> <relação> <objeto>\n```\n\n### Revocar permissão\n```bash\nravi permissions revoke <sujeito> <relação> <objeto>\n```\n\n### Verificar permissão\n```bash\nravi permissions check <sujeito> <permissão> <objeto>\n```\n\nVerifica se a permissão é resolvida (incluindo wildcards e admin).\n\n```bash\n# Dev pode restartar o daemon?\nravi permissions check agent:dev execute group:daemon\n\n# Dev pode acessar sessão dev-grupo1?\nravi permissions check agent:dev access session:dev-grupo1\n\n# Main é superadmin?\nravi permissions check agent:main admin system:*\n```\n\n### Sincronizar com configs\n```bash\nravi permissions sync\n```\n\nRe-lê as configs dos agents e regenera as relações `source=config`. Relações manuais não são afetadas.\n\n### Limpar permissões\n```bash\n# Limpar só manuais\nravi permissions clear\n\n# Limpar TUDO (inclusive config — rode sync depois)\nravi permissions clear --all\n```\n\n## Wildcards\n\nWildcards só funcionam no final do object ID:\n- `*` — tudo\n- `dev-*` — tudo que começa com \"dev-\"\n- ❌ `*-dev` ou `a*b` — inválidos\n\n## Sources\n\n- `config` — Geradas automaticamente a partir da config dos agents (re-sync no boot)\n- `manual` — Criadas via CLI, persistem entre restarts\n\n## Como Funciona a Resolução\n\nQuando o engine verifica `can(agent:dev, execute, group:daemon)`:\n\n1. Agent é superadmin? → checa `(agent:dev, admin, system:*)` → sim = allowed\n2. Relação direta? → checa `(agent:dev, execute, group:daemon)` → sim = allowed\n3. Wildcard? → checa `(agent:dev, execute, group:*)` → sim = allowed\n4. Pattern match? → checa patterns como `group:dae*` → match = allowed\n5. **Tool group?** → se objectType é `tool`, checa se o agent tem algum `toolgroup` que contém essa tool → sim = allowed\n6. Nenhum match → denied\n"
      },
      {
        "path": "skills/image/SKILL.md",
        "content": "---\nname: image\ndescription: |\n  Gera imagens via Gemini Nano Banana 2. Use quando o usuário quiser:\n  - Gerar uma imagem a partir de texto\n  - Editar/transformar uma imagem existente\n  - Criar logos, ilustrações, arte\n  - Gerar e enviar imagem direto no chat\n---\n\n# Image Generation\n\nGera imagens usando Gemini Nano Banana 2 (generateContent com IMAGE modality).\n\n## Como usar\n\n### Gerar imagem simples\n```bash\nravi image generate \"a purple cat floating in space\"\n```\n\n### Modo quality (3 Pro — mais detalhado, mais lento)\n```bash\nravi image generate \"product photo of sneakers\" --mode quality\n```\n\n### Modo fast (3.1 Flash — padrão, rápido)\n```bash\nravi image generate \"abstract art\" --mode fast\n```\n\n### Editar imagem existente (source)\n```bash\nravi image generate \"remove the background and add a sunset\" --source /tmp/photo.png\n```\n\n### Aspect ratio e tamanho\n```bash\nravi image generate \"instagram story background\" --aspect 9:16 --size 2K\n```\n\n### Alta resolução 4K\n```bash\nravi image generate \"landscape wallpaper\" --aspect 16:9 --size 4K\n```\n\n### Gerar e enviar direto no chat\n```bash\nravi image generate \"coffee shop interior\" --send\n```\n\n### Salvar em diretório específico\n```bash\nravi image generate \"product mockup\" -o /tmp/mockups\n```\n\n## Opções\n\n| Flag | Descrição | Default |\n|------|-----------|---------|\n| `--mode <type>` | `fast` (3.1 Flash) ou `quality` (3 Pro) | `fast` |\n| `--source <path>` | Imagem de referência pra edição | — |\n| `--aspect <ratio>` | `1:1`, `2:3`, `3:2`, `3:4`, `4:3`, `9:16`, `16:9`, `21:9` | auto |\n| `--size <size>` | `1K`, `2K`, `4K` | `1K` |\n| `-o, --output <dir>` | Diretório de saída | `/tmp` |\n| `--send` | Envia pro chat automaticamente | `false` |\n| `--caption <text>` | Caption ao enviar (com `--send`) | prompt |\n\n## Retorno\n\nO comando retorna o path da imagem gerada + o comando pra enviar:\n```\n✓ Image saved: /tmp/ravi-image-1234567890.png\n  Send to chat: ravi media send \"/tmp/ravi-image-1234567890.png\"\n```\n\n## Fluxo recomendado\n\n1. Rode `ravi image generate \"prompt\"` — gera a imagem\n2. Se precisa enviar pro chat, use `--send` ou copie o comando `ravi media send` do output\n3. Pra editar uma imagem: passe `--source` com o path da imagem original\n\n## Limitações\n\n- Modelos são preview — podem mudar\n- Requer `GEMINI_API_KEY` configurada no `~/.ravi/.env`\n- Prompts podem ser bloqueados por filtros de segurança\n- Source image: PNG, JPEG, WebP, GIF\n\n## Configuração\n\n- `GEMINI_API_KEY` — obrigatória, no `~/.ravi/.env`\n- `GEMINI_IMAGE_MODEL` — override do modelo (ignora --mode)\n"
      },
      {
        "path": "skills/heartbeat/SKILL.md",
        "content": "---\nname: heartbeat-manager\ndescription: |\n  Gerencia heartbeat dos agents. Use quando o usuário quiser:\n  - Configurar check-ins periódicos para agents\n  - Ativar/desativar heartbeat\n  - Definir intervalo e horários ativos\n  - Disparar heartbeat manualmente\n---\n\n# Heartbeat Manager\n\nHeartbeat são check-ins periódicos que um agent faz. O agent lê o arquivo HEARTBEAT.md do seu workspace e executa as instruções.\n\n## Como Funciona\n\n1. Agent tem heartbeat habilitado com intervalo (ex: 30min)\n2. A cada intervalo, o daemon envia prompt pro agent\n3. Agent lê HEARTBEAT.md e executa (ex: verificar pendências, enviar resumo)\n\n## Comandos\n\n### Ver status de todos\n```bash\nravi heartbeat status\n```\n\n### Ver config de um agent\n```bash\nravi heartbeat show <agent>\n```\n\n### Habilitar heartbeat\n```bash\nravi heartbeat enable <agent>\nravi heartbeat enable <agent> 30m    # Com intervalo\n```\n\n### Desabilitar heartbeat\n```bash\nravi heartbeat disable <agent>\n```\n\n### Configurar propriedades\n```bash\nravi heartbeat set <agent> interval 1h          # Intervalo\nravi heartbeat set <agent> model haiku          # Modelo (economia)\nravi heartbeat set <agent> active-hours 09:00-22:00  # Horário ativo\nravi heartbeat set <agent> active-hours always  # Sempre ativo\n```\n\n### Disparar manualmente\n```bash\nravi heartbeat trigger <agent>\n```\n\n## Arquivo HEARTBEAT.md\n\nCada agent precisa ter um `HEARTBEAT.md` no seu workspace com instruções do que fazer no check-in.\n\nExemplo:\n```markdown\n# Heartbeat - Check-in Periódico\n\n## O Que Verificar\n- Tarefas pendentes\n- Erros recentes nos logs\n- Mensagens não respondidas\n\n## Quando Notificar\n- Se algo importante ficou pendente\n- Se um processo crashou\n- Se há muito tempo sem interação\n\n## Como Notificar\nUse sessions inform para enviar mensagem:\nravi sessions inform <session-name> \"mensagem\"\n```\n\n## Exemplos\n\nConfigurar heartbeat básico:\n```bash\nravi heartbeat enable main 30m\n```\n\nHeartbeat só em horário comercial:\n```bash\nravi heartbeat enable main 1h\nravi heartbeat set main active-hours 09:00-18:00\n```\n\nUsar modelo mais barato:\n```bash\nravi heartbeat set main model haiku\n```\n\nTestar configuração:\n```bash\nravi heartbeat trigger main\nravi daemon logs -f\n```\n"
      },
      {
        "path": "skills/sessions/SKILL.md",
        "content": "---\nname: sessions\ndescription: |\n  Gerencia sessões do sistema Ravi. Use quando o usuário quiser:\n  - Listar, ver detalhes ou renomear sessões\n  - Resetar ou deletar sessões\n  - Configurar modelo ou thinking level por sessão\n  - Criar sessões efêmeras com TTL\n  - Estender, manter ou excluir sessões efêmeras\n  - Enviar prompts, perguntas ou comandos entre sessões\n  - Ler histórico de mensagens de uma sessão\n---\n\n# Sessions Manager\n\nSessões são conversas persistentes entre agents e usuários. Cada sessão tem um nome único, um agent associado, e pode ter canal de saída (WhatsApp, Matrix, etc).\n\n## Tipos de Sessão\n\n- **Permanent** (padrão): Sessão normal, sem expiração.\n- **Ephemeral**: Sessão com TTL (time-to-live). Expira automaticamente após o tempo definido. 10 minutos antes de expirar, o agent recebe um aviso com comandos CLI para estender, manter ou excluir.\n\n## Comandos\n\n### Listagem e Info\n\n```bash\n# Listar todas as sessões (mostra tipo e data de expiração)\nravi sessions list\n\n# Filtrar por agent\nravi sessions list --agent <id>\n\n# Listar só efêmeras\nravi sessions list --ephemeral\n\n# Ver detalhes de uma sessão\nravi sessions info <name>\n\n# Ler histórico de mensagens (normalizado, sem tool calls)\nravi sessions read <name> [-n count]\n```\n\n### Gerenciamento\n\n```bash\n# Renomear display name\nravi sessions rename <name> \"Novo Nome\"\n\n# Definir modelo override\nravi sessions set-model <name> <model>\n\n# Definir thinking level\nravi sessions set-thinking <name> <level>\n\n# Resetar sessão (limpa conversa, mantém config)\nravi sessions reset <name>\n\n# Deletar sessão permanentemente (abort + delete)\nravi sessions delete <name>\n```\n\n### Sessões Efêmeras\n\n```bash\n# Tornar sessão efêmera com TTL (ex: 5h, 30m, 1d)\nravi sessions set-ttl <name> <duration>\n\n# Estender TTL de uma sessão efêmera (+5h default)\nravi sessions extend <name> [duration]\n\n# Tornar sessão efêmera em permanente\nravi sessions keep <name>\n```\n\n**Fluxo automático:**\n1. Sessão criada com `set-ttl` recebe TTL\n2. 10 min antes de expirar, o agent recebe aviso via `[System] Inform:` com os comandos CLI\n3. O agent pode executar `extend`, `keep`, ou `delete`\n4. Sem ação → sessão é automaticamente deletada pelo runner\n\n### Comunicação Inter-Sessão\n\n```bash\n# Enviar prompt e esperar resposta (streaming)\nravi sessions send <name> \"mensagem\" [-a agent] [-i]\n# -a: criar sessão com esse agent se não existir\n# -i: modo interativo (loop)\n\n# Perguntar algo (fire-and-forget, agent pergunta no chat se não souber)\nravi sessions ask <name> \"pergunta\" [sender]\n\n# Responder uma pergunta de outra sessão (agent NUNCA silencia)\nravi sessions answer <name> \"resposta\" [sender]\n\n# Executar comando (fire-and-forget, agent executa sem responder)\nravi sessions execute <name> \"tarefa\"\n\n# Informar algo (fire-and-forget, agent pode silenciar se irrelevante)\nravi sessions inform <name> \"info\"\n```\n\n## Notas\n\n- **Reset vs Delete**: `reset` limpa a conversa mas mantém nome/routing/config. `delete` remove a sessão inteira.\n- **Session names**: Nomes legíveis, únicos, sem pontos (`.`). Gerados automaticamente ou definidos manualmente.\n- **Source automático**: Todos os comandos de comunicação incluem source (channel/chatId) automaticamente — o agent sabe onde responder.\n"
      },
      {
        "path": "skills/daemon/SKILL.md",
        "content": "---\nname: daemon-manager\ndescription: |\n  Controla o daemon do Ravi. Use quando o usuário quiser:\n  - Ver status do daemon\n  - Reiniciar o daemon\n  - Ver logs\n  - Instalar/desinstalar serviço do sistema\n---\n\n# Daemon Manager\n\nO daemon é o processo principal que roda o bot e os gateways.\n\n## Comandos\n\n### Status\n```bash\nravi daemon status\n```\n\n### Iniciar\n```bash\nravi daemon start\n```\n\n### Parar\n```bash\nravi daemon stop\n```\n\n### Reiniciar\n```bash\nravi daemon restart\nravi daemon restart --message \"Motivo do restart\"\n```\n\n### Logs\n```bash\nravi daemon logs              # Últimas linhas\nravi daemon logs --tail 50    # Últimas 50 linhas\nravi daemon logs --follow     # Acompanhar em tempo real\nravi daemon logs --clear      # Limpar logs\nravi daemon logs --path       # Mostrar caminho do arquivo\n```\n\n### Modo Dev\n```bash\nravi daemon dev   # Rebuild automático ao editar código\n```\n\n### Serviço do Sistema\n\nInstalar como serviço (inicia no boot):\n```bash\nravi daemon install\n```\n\nDesinstalar:\n```bash\nravi daemon uninstall\n```\n\n## Arquivos\n\n- **Logs**: `~/.ravi/logs/daemon.log`\n- **PID**: gerenciado pelo launchd/systemd\n- **Env**: `~/.ravi/.env`\n\n## Editar variáveis de ambiente\n```bash\nravi daemon env\n```\n"
      },
      {
        "path": "skills/instances/SKILL.md",
        "content": "---\nname: instances-manager\ndescription: |\n  Gerencia instâncias de canais do Ravi. Use quando o usuário quiser:\n  - Criar, listar ou configurar instâncias (contas omni)\n  - Conectar/desconectar contas WhatsApp, Matrix, etc\n  - Definir policies de DM e grupo por instância\n  - Gerenciar rotas de uma instância específica\n  - Aprovar ou rejeitar pendências de acesso\n---\n\n# Instances Manager\n\nInstâncias são a entidade central de configuração do Ravi. Cada instância representa uma conta conectada (WhatsApp, Matrix, etc) com seu próprio agent, policies e rotas.\n\n## Comandos Principais\n\n### Listar instâncias\n```bash\nravi instances list\n```\n\n### Ver detalhes\n```bash\nravi instances show <name>\n```\n\n### Criar instância\n```bash\nravi instances create <name>\nravi instances create vendas --agent vendas-agent --channel whatsapp\n```\n\n### Configurar propriedades\n```bash\nravi instances set <name> <key> <value>\n```\n\nKeys disponíveis:\n- `agent` - Agent ID padrão desta instância\n- `dmPolicy` - Política para DMs: `open` | `pairing` | `closed`\n- `groupPolicy` - Política para grupos: `open` | `allowlist` | `closed`\n- `dmScope` - Escopo de sessões DM: `main` | `per-peer` | `per-channel-peer` | `per-account-channel-peer`\n- `instanceId` - UUID omni (normalmente auto-preenchido no connect)\n- `channel` - Canal: `whatsapp` | `matrix` | etc\n\n### Remover instância\n```bash\nravi instances delete <name>\n```\n\n## Conexão de Canal\n\n### Conectar WhatsApp\n```bash\nravi instances connect <name>\nravi instances connect vendas --agent vendas-agent\n```\n\n### Ver status omni\n```bash\nravi instances status <name>\n```\n\n### Desconectar\n```bash\nravi instances disconnect <name>\n```\n\n## Policies\n\nPolicies controlam quem pode iniciar conversa com o bot desta instância:\n\n| Policy | Contexto | Comportamento |\n|--------|----------|---------------|\n| `dmPolicy=open` | DMs | Aceita qualquer DM |\n| `dmPolicy=pairing` | DMs | Só aceita contatos previamente aprovados |\n| `dmPolicy=closed` | DMs | Rejeita todos os DMs |\n| `groupPolicy=open` | Grupos | Aceita qualquer grupo |\n| `groupPolicy=allowlist` | Grupos | Só grupos com rota explícita (`ravi instances routes add`) |\n| `groupPolicy=closed` | Grupos | Rejeita todos os grupos |\n\n```bash\nravi instances set main dmPolicy pairing\nravi instances set vendas groupPolicy allowlist\n```\n\n## Rotas por Instância\n\n```bash\nravi instances routes list <name>\nravi instances routes show <name> <pattern>\nravi instances routes add <name> <pattern> <agent>\nravi instances routes remove <name> <pattern>\nravi instances routes set <name> <pattern> <key> <value>\n```\n\nPadrões suportados:\n- `5511*` - Prefixo de telefone\n- `group:123456` - Grupo específico\n- `thread:abc123` - Thread dentro de grupo (maior prioridade)\n- `*` - Catch-all\n\n## Pendências\n\nQuando `dmPolicy=pairing` ou `groupPolicy=allowlist`, contatos/grupos desconhecidos ficam pendentes:\n\n```bash\nravi instances pending list <name>\nravi instances pending approve <name> <id>    # aprova + cria rota\nravi instances pending reject <name> <id>     # rejeita\n```\n\n## Exemplos de Setup\n\n### Bot público (responde tudo)\n```bash\nravi instances create main --agent main --channel whatsapp\nravi instances set main dmPolicy open\nravi instances set main groupPolicy open\nravi instances connect main\n```\n\n### Bot controlado (só contatos aprovados)\n```bash\nravi instances create suporte --agent suporte-agent\nravi instances set suporte dmPolicy pairing\nravi instances set suporte groupPolicy allowlist\nravi instances connect suporte\n# Quando alguém envia mensagem → aparece em `pending list`\nravi instances pending list suporte\nravi instances pending approve suporte 5511999999999\n```\n\n### Multi-instância\n```bash\nravi instances create vendas --agent vendas-agent\nravi instances create suporte --agent suporte-agent\nravi instances set vendas dmPolicy open\nravi instances set suporte dmPolicy pairing\nravi instances connect vendas\nravi instances connect suporte\n```\n"
      },
      {
        "path": "skills/skills/SKILL.md",
        "content": "---\nname: skill-creator\ndescription: |\n  Guia para criar skills no Claude Code. Use quando o usuário quiser:\n  - Criar uma nova skill\n  - Entender como skills funcionam\n  - Configurar frontmatter de skills\n  - Adicionar skills a plugins\n---\n\n# Skill Creator - Guia Completo\n\nSkills estendem as capacidades do Claude. São arquivos markdown com instruções que Claude segue quando a skill é invocada.\n\n## Estrutura de uma Skill\n\n```\nskills/\n└── minha-skill/\n    └── SKILL.md          # Arquivo principal (obrigatório)\n    ├── template.md       # Template opcional\n    ├── examples/         # Exemplos opcionais\n    └── scripts/          # Scripts auxiliares\n```\n\n## Formato do SKILL.md\n\n```yaml\n---\nname: nome-da-skill\ndescription: |\n  Descrição detalhada. Claude usa isso para decidir\n  quando carregar a skill automaticamente.\n---\n\n# Título da Skill\n\nInstruções que Claude segue quando a skill é ativada.\n```\n\n## Frontmatter - Todas as Opções\n\n| Campo | Obrigatório | Descrição |\n|-------|-------------|-----------|\n| `name` | Não | Nome da skill. Se omitido, usa o nome da pasta |\n| `description` | Recomendado | Quando usar. Claude usa pra decidir auto-invocação |\n| `argument-hint` | Não | Hint no autocomplete: `[issue-number]` |\n| `disable-model-invocation` | Não | `true` = só user pode invocar (default: false) |\n| `user-invocable` | Não | `false` = esconde do menu / (default: true) |\n| `allowed-tools` | Não | Tools permitidas: `Read, Grep, Glob` |\n| `model` | Não | Modelo específico para a skill |\n| `context` | Não | `fork` = roda em subagent isolado |\n| `agent` | Não | Tipo de subagent quando `context: fork` |\n| `hooks` | Não | Hooks específicos da skill |\n\n## Tipos de Skills\n\n### 1. Skill de Referência (conhecimento)\nClaude aplica ao trabalho atual. Roda inline.\n\n```yaml\n---\nname: api-conventions\ndescription: Padrões de API do projeto\n---\n\nAo criar endpoints:\n- Use nomes RESTful\n- Retorne erros consistentes\n- Valide requests\n```\n\n### 2. Skill de Tarefa (ação)\nInstruções passo-a-passo. Geralmente user-invoked.\n\n```yaml\n---\nname: deploy\ndescription: Deploy para produção\ncontext: fork\ndisable-model-invocation: true\n---\n\nDeploy da aplicação:\n1. Rodar testes\n2. Build\n3. Push para produção\n```\n\n## Controle de Invocação\n\n| Configuração | User pode | Claude pode | Uso |\n|--------------|-----------|-------------|-----|\n| (default) | Sim | Sim | Skills gerais |\n| `disable-model-invocation: true` | Sim | Não | Ações com side-effects |\n| `user-invocable: false` | Não | Sim | Conhecimento de background |\n\n## Variáveis de Substituição\n\n| Variável | Descrição |\n|----------|-----------|\n| `$ARGUMENTS` | Todos os argumentos passados |\n| `$ARGUMENTS[N]` ou `$N` | Argumento específico (0-indexed) |\n| `${CLAUDE_SESSION_ID}` | ID da sessão atual |\n| `` !`command` `` | Executa comando e insere output |\n\n## Exemplo: Skill com Argumentos\n\n```yaml\n---\nname: fix-issue\ndescription: Corrige uma issue do GitHub\ndisable-model-invocation: true\n---\n\nCorrigir issue #$ARGUMENTS:\n\n1. Ler descrição da issue\n2. Implementar correção\n3. Escrever testes\n4. Criar commit\n```\n\nUso: `/fix-issue 123`\n\n## Exemplo: Skill com Contexto Dinâmico\n\n```yaml\n---\nname: pr-summary\ndescription: Resume um PR\ncontext: fork\nagent: Explore\nallowed-tools: Bash(gh *)\n---\n\n## Contexto do PR\n- Diff: !`gh pr diff`\n- Comentários: !`gh pr view --comments`\n\n## Tarefa\nResuma este PR...\n```\n\n## Onde Colocar Skills\n\n| Local | Caminho | Alcance |\n|-------|---------|---------|\n| Pessoal | `~/.claude/skills/` | Todos os projetos |\n| Projeto | `.claude/skills/` | Este projeto |\n| Plugin | `plugin/skills/` | Onde plugin está ativo |\n\n## Criando uma Skill - Passo a Passo\n\n1. **Criar diretório:**\n```bash\nmkdir -p ~/.claude/skills/minha-skill\n```\n\n2. **Criar SKILL.md:**\n```bash\ncat > ~/.claude/skills/minha-skill/SKILL.md << 'EOF'\n---\nname: minha-skill\ndescription: Descrição clara do que faz e quando usar\n---\n\nInstruções aqui...\nEOF\n```\n\n3. **Testar:**\n```\n/minha-skill\n```\n\n## Dicas\n\n- Mantenha SKILL.md < 500 linhas\n- Use arquivos separados para referências longas\n- Descrição clara = melhor auto-invocação\n- `allowed-tools` restringe para segurança\n- `context: fork` isola side-effects\n\n## Skills em Plugins\n\nPara distribuir skills:\n\n```\nmeu-plugin/\n├── .claude-plugin/\n│   └── plugin.json\n└── skills/\n    └── minha-skill/\n        └── SKILL.md\n```\n\nSkills de plugins usam namespace: `/meu-plugin:minha-skill`\n"
      },
      {
        "path": "skills/outbound/SKILL.md",
        "content": "---\nname: outbound-manager\ndescription: |\n  Gerencia filas de outbound do sistema Ravi. Use quando o usuário quiser:\n  - Criar, configurar ou gerenciar filas de mensagens automatizadas\n  - Adicionar contatos/leads a uma fila\n  - Ver status, relatórios ou histórico de conversas\n  - Qualificar leads ou atualizar contexto\n  - Pausar/iniciar filas ou resetar entries\n---\n\n# Outbound Manager\n\nVocê gerencia as filas de outbound do Ravi. Outbound são campanhas de mensagens automatizadas para prospecção, follow-up, ou comunicação em massa.\n\n## Comandos de Fila\n\n### Listar filas\n```bash\nravi outbound list\n```\n\n### Ver detalhes da fila\n```bash\nravi outbound show <id>\n```\n\n### Criar fila\n```bash\nravi outbound create \"<nome>\" --instructions \"<prompt>\" --every <interval> --stages '<json>'\n```\n\nOpções obrigatórias:\n- `--instructions <text>` - Instruções do agent\n- `--every <interval>` - Intervalo entre entries (ex: 5m, 1h)\n- `--stages <json>` - Pipeline stages (ver seção abaixo)\n\nOpções extras:\n- `--agent <id>` - Agent que processa\n- `--description <text>` - Descrição da fila\n- `--active-start <HH:MM>` - Horário início (ex: 09:00)\n- `--active-end <HH:MM>` - Horário fim (ex: 22:00)\n- `--tz <timezone>` - Fuso horário\n- `--max-rounds <n>` - Máximo de rounds por entry\n\n### Iniciar/Pausar fila\n```bash\nravi outbound start <id>\nravi outbound pause <id>\n```\n\n### Configurar propriedades\n```bash\nravi outbound set <id> <key> <value>\n```\nKeys: name, instructions, every, agent, description, active-start, active-end, tz, stages, max-rounds\n\n### Deletar fila\n```bash\nravi outbound rm <id>\n```\n\n### Executar manualmente\n```bash\nravi outbound run <id>\n```\n\n## Comandos de Entries\n\n### Adicionar entry\n```bash\nravi outbound add <queueId> <phone> --name \"Nome\" --context '{\"empresa\":\"Acme\"}'\n```\n\nOu adicionar por tag:\n```bash\nravi outbound add <queueId> - --tag \"leads\"\n```\n\n### Listar entries\n```bash\nravi outbound entries <queueId>\n```\n\n### Ver status de entry\n```bash\nravi outbound status <entryId>\n```\n\n### Ver histórico de chat\n```bash\nravi outbound chat <entryId>\n```\n\n### Atualizar contexto\n```bash\nravi outbound context <entryId> '{\"empresa\":\"Nova Info\"}'\n```\n\n### Qualificar lead / Mudar estágio\n```bash\nravi outbound qualify <entryId> <stage>\n```\nAceita qualquer estágio definido na fila. Cada fila define seus próprios estágios.\n\n### Marcar como concluído\n```bash\nravi outbound done <entryId>\nravi outbound complete <entryId>\nravi outbound skip <entryId>\n```\n\n### Resetar entry\n```bash\nravi outbound reset <entryId>\nravi outbound reset <entryId> --full  # Limpa contexto também\n```\n\n## Relatório Completo\n\n```bash\nravi outbound report              # Todas as filas\nravi outbound report <queueId>    # Fila específica\n```\n\n## Enviar Mensagem Manual\n\n```bash\nravi outbound send <entryId> \"Mensagem\"\n```\n\nOpções:\n- `--account <id>` - Conta WhatsApp\n- `--typing-delay <ms>` - Delay de digitação\n- `--pause <ms>` - Pausa antes de digitar\n\n## Pipeline Stages\n\nCada fila **deve** definir seus próprios estágios. Não existe padrão — defina o funil que faz sentido pro caso de uso.\n\n### Formato\n```json\n[\n  { \"name\": \"novo\" },\n  { \"name\": \"engajado\", \"delay\": 30 },\n  { \"name\": \"qualificado\" },\n  { \"name\": \"perdido\" }\n]\n```\n\n- `name` — identificador do estágio\n- `delay` — minutos para follow-up automático (null/omitido = sem follow-up)\n\n### Exemplos por caso de uso\n\n**Vendas B2B:**\n```bash\nravi outbound create \"Prospecção\" --instructions \"...\" --every 5m \\\n  --stages '[{\"name\":\"cold\"},{\"name\":\"engajado\",\"delay\":30},{\"name\":\"reuniao_marcada\",\"delay\":1440},{\"name\":\"proposta\",\"delay\":4320},{\"name\":\"fechado\"},{\"name\":\"perdido\"}]'\n```\n\n**Recrutamento:**\n```bash\nravi outbound set <id> stages '[{\"name\":\"novo\"},{\"name\":\"respondeu\",\"delay\":30},{\"name\":\"interessado\",\"delay\":60},{\"name\":\"agendou_entrevista\",\"delay\":1440},{\"name\":\"contratado\"},{\"name\":\"recusou\"}]'\n```\n\n**Cobrança:**\n```bash\nravi outbound set <id> stages '[{\"name\":\"aviso\"},{\"name\":\"lembrete\",\"delay\":1440},{\"name\":\"urgente\",\"delay\":2880},{\"name\":\"ultima_chance\",\"delay\":4320},{\"name\":\"inadimplente\"}]'\n```\n\n### Como funciona\n- O agent recebe os estágios disponíveis no prompt automaticamente\n- `qualify` valida contra os estágios da fila\n- Follow-up automático usa o `delay` do estágio atual da entry\n"
      },
      {
        "path": "skills/events/SKILL.md",
        "content": "---\nname: events\ndescription: |\n  Referência do sistema de eventos NATS. Use quando precisar:\n  - Entender os tópicos e fluxo de eventos do Ravi\n  - Emitir eventos manualmente via código\n  - Debugar fluxo de mensagens entre componentes\n---\n\n# NATS Event Bus\n\nO NATS é o pub/sub central do Ravi. Todas as mensagens, prompts, tool calls e respostas passam por ele como eventos em tópicos.\n\n## Conceitos\n\n- **Topic/Subject**: Namespace hierárquico separado por `.` (ex: `ravi.session.main.prompt`)\n- **Event**: Payload JSON publicado num subject\n- **Wildcards**: `*` casa com um nível, `>` casa com múltiplos níveis\n- **Connection**: TCP direto para `nats://127.0.0.1:4222` (sem HTTP/WebSocket intermediário)\n\n## Tópicos do Ravi\n\n### Sessões (por session name)\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.session.{name}.prompt` | `{ prompt, source?: { channel, accountId, chatId }, context?, _agentId?, _outbound?, _queueId?, _entryId? }` |\n| `ravi.session.{name}.response` | `{ response, target?: { channel, accountId, chatId }, _emitId, _instanceId, _pid, _v: 2 }` |\n| `ravi.session.{name}.claude` | Evento bruto do SDK Claude: `{ type: \"system\"\\|\"assistant\"\\|\"result\"\\|\"silent\"\\|..., _source? }` |\n| `ravi.session.{name}.tool` | Start: `{ event: \"start\", toolId, toolName, safety, input, timestamp, sessionName, agentId }` / End: `{ event: \"end\", toolId, toolName, output, isError, durationMs, timestamp, sessionName, agentId }` |\n| `ravi.session.{name}.stream` | `{ chunk }` — streaming de text deltas pro TUI |\n| `ravi.session.abort` | `{ sessionKey?, sessionName? }` — abortar sessão ephemeral |\n\n> **Nota:** O tópico usa o **session name** (ex: `agent-main-abc123`), não o session key (ex: `agent:main:main`). O prompt vai via JetStream WorkQueue stream (`SESSION_PROMPTS`), os demais são plain NATS pub/sub.\n\n### Inbound (canais → bot)\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.inbound.reaction` | `{ targetMessageId, emoji, senderId }` |\n| `ravi.inbound.reply` | `{ targetMessageId, text, senderId }` |\n| `ravi.inbound.pollVote` | `{ pollMessageId, votes: [{ name, voters[] }] }` — subscriber existe, publisher vem do omni |\n\n> As mensagens inbound dos canais chegam via **omni JetStream** nos subjects `message.received.{channelType}.{instanceId}`, não via pub/sub ravi. O `OmniConsumer` consome esses streams e traduz para prompts de sessão.\n\n### Outbound (bot → gateway → omni)\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.outbound.deliver` | `{ channel, accountId, to, text?, poll?, typingDelayMs?, pauseMs?, replyTopic? }` |\n| `ravi.outbound.reaction` | `{ channel, accountId, chatId, messageId, emoji }` |\n| `ravi.outbound.receipt` | `{ channel, accountId, chatId, senderId, messageIds[] }` — sem subscriber no ravi, consumido pelo omni |\n| `ravi.outbound.refresh` | `{}` — sinal de refresh de filas outbound |\n| `ravi.outbound.trigger` | `{ queueId }` — trigger manual de fila outbound |\n\n### Mídia\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.media.send` | `{ channel, accountId, chatId, filePath, mimetype, type: \"image\"\\|\"video\"\\|\"audio\"\\|\"document\", filename, caption? }` |\n\n### Contatos e Aprovações\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.contacts.pending` | `{ type: \"account\", channel, accountId, senderId, chatId, isGroup }` |\n| `ravi.approval.request` | `{ type: \"plan\"\\|\"spec\"\\|\"question\", sessionName, agentId, delegated, channel, chatId, timestamp, questionCount? }` |\n| `ravi.approval.response` | `{ type: \"plan\"\\|\"spec\"\\|\"question\", sessionName, agentId, approved, reason?, answers?, timestamp }` |\n\n### Instâncias\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.instances.unregistered` | `{ instanceId, channelType, subject, from, chatId, isGroup, contentType, timestamp }` — cooldown 5min por instanceId |\n| `ravi.whatsapp.qr.{instanceId}` | `{ type: \"qr\", instanceId, qr, channelType }` |\n| `ravi.whatsapp.connected.{instanceId}` | `{ type: \"connected\", instanceId, channelType, profileName, ownerIdentifier }` |\n| `ravi.whatsapp.group.{op}` | `{ accountId, replyTopic, ... }` — ops: list, info, create, leave, add, remove, join (request-reply) |\n\n### Auditoria\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.audit.denied` | `{ type: \"env_spoofing\"\\|\"executable\"\\|\"session_scope\"\\|\"tool\"\\|\"group\", agentId, denied, reason, detail? }` |\n\n### Sistema e Config\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.config.changed` | `{}` — configuração alterada via CLI |\n| `ravi.triggers.refresh` | `{}` — refresh de subscriptions de triggers |\n| `ravi.triggers.test` | `{ triggerId }` — test manual de trigger |\n| `ravi.cron.refresh` | `{}` — refresh de timers de cron |\n| `ravi.cron.trigger` | `{ jobId }` — trigger manual de cron job |\n| `ravi.heartbeat.refresh` | `{}` — refresh de timers heartbeat |\n| `ravi.copilot.watch` | `{ team, agentId }` — copilot inbox watcher |\n\n### CLI Tools (emitidos pelo bot)\n\n| Tópico | Payload |\n|--------|---------|\n| `ravi.{sessionKey}.cli.{group}.{command}` | Evento de execução de CLI tool pelo agent |\n\n## API (src/nats.ts)\n\n```typescript\nimport { nats } from \"./nats.js\";\n\n// Publicar evento\nawait nats.emit(\"ravi.session.main.prompt\", { prompt: \"oi\" });\n\n// Subscribir a tópicos (wildcards)\nfor await (const event of nats.subscribe(\"ravi.session.*.prompt\")) {\n  console.log(event.topic, event.data);\n}\n\n// Múltiplos tópicos\nfor await (const event of nats.subscribe(\"ravi.session.*.response\", \"ravi.session.*.tool\")) {\n  console.log(event.topic, event.data);\n}\n```\n\n## Relação com Triggers\n\nO Ravi tem um sistema de **triggers** (`ravi triggers`) que reagem automaticamente a eventos NATS.\n\n- **NATS** = barramento de eventos (pub/sub)\n- **triggers** = reações automáticas quando um evento matching acontece\n\nPara gerenciar triggers, use `ravi triggers --help`.\n"
      },
      {
        "path": "skills/routes/SKILL.md",
        "content": "---\nname: routes-manager\ndescription: |\n  Gerencia rotas de mensagens do Ravi. Use quando o usuário quiser:\n  - Criar, listar ou remover rotas\n  - Direcionar contatos/grupos/threads para agents específicos\n  - Configurar prioridade, policy e dmScope de rotas\n  - Ver qual agent atende qual padrão\n---\n\n# Routes Manager\n\nRotas direcionam mensagens para agents baseado em padrões. São sempre gerenciadas via `ravi instances routes <name>` — rotas pertencem a uma instância.\n\n## Comandos\n\n### Listar rotas\n```bash\nravi instances routes list <name>\n```\n\n### Ver detalhes\n```bash\nravi instances routes show <name> <pattern>\n```\n\n### Adicionar rota\n```bash\nravi instances routes add <name> <pattern> <agent>\nravi instances routes add vendas \"5511*\" vendas-agent --priority 10\nravi instances routes add vendas \"group:123456\" suporte --policy closed\nravi instances routes add vendas \"*\" main --channel whatsapp   # só pra um canal\n```\n\nExemplos de padrões:\n- `5511*` - Todos com DDD 11\n- `*999*` - Números contendo 999\n- `group:123456` - Grupo específico do WhatsApp\n- `thread:abc123` - Thread específica dentro de um grupo\n- `*` - Catch-all (fallback)\n\n### Remover rota (soft-delete, recuperável)\n```bash\nravi instances routes remove <name> <pattern>\nravi instances routes restore <name> <pattern>   # recuperar\nravi instances routes deleted [name]             # ver deletadas\n```\n\n### Configurar propriedades\n```bash\nravi instances routes set <name> <pattern> <key> <value>\n```\n\nKeys disponíveis:\n- `agent` - Agent ID alvo\n- `priority` - Prioridade (maior = mais prioritário)\n- `dmScope` - Escopo de DM (main, per-peer, per-channel-peer, per-account-channel-peer)\n- `session` - Nome fixo de sessão (bypassa auto-geração)\n- `policy` - Policy override (open, pairing, closed, allowlist)\n- `channel` - Limitar a canal específico (whatsapp, telegram, etc). `-` pra limpar.\n\n## Prioridade de Resolução\n\n1. Rota `thread:ID` (mais específica — thread dentro de grupo)\n2. Rota `group:ID` ou padrão de grupo\n3. Rota por telefone/padrão\n4. Mapeamento agent da instância (`ravi instances set <name> agent <agent>`)\n5. Agent default\n\nDentro do mesmo nível: rotas com `channel` específico ganham de rotas sem channel, depois desempata por `priority` DESC.\n\n## Herança de Policy\n\n```\nroute.policy → instance.dmPolicy/groupPolicy → \"open\"\n```\n\n## Exemplos\n\nRotear grupo para agent especializado:\n```bash\nravi instances routes add main \"group:120363123456789\" projeto-x\n```\n\nRotear thread específica dentro de um grupo:\n```bash\nravi instances routes add main \"thread:msg-abc123\" suporte-vip\n```\n\nRotear todos de SP para agent:\n```bash\nravi instances routes add main \"5511*\" vendas\n```\n\nDefinir política restrita em rota específica:\n```bash\nravi instances routes set main \"group:123456\" policy closed\n```\n\nDefinir fallback:\n```bash\nravi instances routes add main \"*\" main\n```\n\nPara gerenciar contacts: use a skill `ravi-system:contacts`\n"
      },
      {
        "path": "skills/whatsapp/SKILL.md",
        "content": "---\nname: whatsapp-manager\ndescription: |\n  Gerencia funcionalidades do WhatsApp via Baileys. Use quando o usuário quiser:\n  - Criar, gerenciar ou sair de grupos\n  - Adicionar/remover membros de grupos\n  - Gerar ou revogar links de convite\n  - Renomear grupos ou mudar descrição\n  - Alterar configurações de grupo (anúncio, locked)\n  - Entrar em grupo via link de convite\n  - Listar todos os grupos que o bot participa\n---\n\n# WhatsApp Manager\n\nFuncionalidades do WhatsApp expostas via Baileys. Permite gerenciar grupos, membros, convites e configurações diretamente pelo CLI.\n\n**Importante:** Todos os comandos precisam que o daemon esteja rodando com WhatsApp conectado. Os comandos se comunicam com o daemon via NATS (request/reply).\n\n**Gerenciamento de contas/instâncias:** use `ravi instances` (conectar, desconectar, status, policies).\n\n## Gerenciamento de Grupos\n\n### Listar grupos\n```bash\nravi whatsapp group list\n```\n\n### Ver info de um grupo\n```bash\nravi whatsapp group info <groupId>\n```\n\nO `groupId` aceita:\n- JID completo: `120363425628305127@g.us`\n- Formato normalizado: `group:120363425628305127`\n\n### Criar grupo\n```bash\nravi whatsapp group create \"Nome do Grupo\" \"5511999999999,5511888888888\"\n```\n\nParticipantes separados por vírgula. Aceita números de telefone ou JIDs.\n\n**Com agent (recomendado):** Auto-aprova o contato e cria a rota pro agent num comando só:\n```bash\nravi whatsapp group create \"Vida - Health\" \"5511947879044\" --agent health\n```\n\nSaída:\n```\n✓ Group created: Vida - Health\n  ID:           120363405113391144@g.us\n  Participants: 2\n  Contact:      approved\n  Route:        health\n```\n\n### Sair de um grupo\n```bash\nravi whatsapp group leave <groupId>\n```\n\n## Membros\n\n### Adicionar participantes\n```bash\nravi whatsapp group add <groupId> \"5511999999999,5511888888888\"\n```\n\n### Remover participantes\n```bash\nravi whatsapp group remove <groupId> \"5511999999999\"\n```\n\n### Promover a admin\n```bash\nravi whatsapp group promote <groupId> \"5511999999999\"\n```\n\n### Remover admin\n```bash\nravi whatsapp group demote <groupId> \"5511999999999\"\n```\n\n## Convites\n\n### Gerar link de convite\n```bash\nravi whatsapp group invite <groupId>\n```\n\nRetorna o link `https://chat.whatsapp.com/...`\n\n### Revogar link (gera novo)\n```bash\nravi whatsapp group revoke-invite <groupId>\n```\n\n### Entrar via link\n```bash\nravi whatsapp group join \"https://chat.whatsapp.com/ABC123\"\n# ou só o código:\nravi whatsapp group join ABC123\n```\n\n## Configurações\n\n### Renomear grupo\n```bash\nravi whatsapp group rename <groupId> \"Novo Nome\"\n```\n\n### Mudar descrição\n```bash\nravi whatsapp group description <groupId> \"Nova descrição do grupo\"\n```\n\n### Alterar settings\n```bash\nravi whatsapp group settings <groupId> <setting>\n```\n\nSettings disponíveis:\n- `announcement` — só admins enviam mensagens\n- `not_announcement` — todos enviam mensagens\n- `locked` — só admins editam info do grupo\n- `unlocked` — todos editam info do grupo\n\n## Multi-account\n\nTodos os comandos aceitam `--account <id>` pra especificar qual conta WhatsApp usar. Default: primeira instância.\n\n```bash\nravi whatsapp group list --account business\nravi whatsapp group create \"Equipe\" \"5511999\" --account business\n```\n\n## Exemplos Práticos\n\n### Criar grupo pra um agent\n```bash\n# Tudo num comando só:\nravi whatsapp group create \"Vida - Finanças\" \"5511947879044\" --agent financas\n```\n\nSem `--agent`, precisa rotear manualmente:\n```bash\nravi whatsapp group create \"Grupo Avulso\" \"5511999999999\"\nravi instances routes add main \"group:<id>\" meu-agent\n```\n\n### Gerenciar membros de equipe\n```bash\n# Ver quem tá no grupo\nravi whatsapp group info group:120363425628305127\n\n# Adicionar novo membro\nravi whatsapp group add group:120363425628305127 \"5511777777777\"\n\n# Promover a admin\nravi whatsapp group promote group:120363425628305127 \"5511777777777\"\n```\n\n### Gerar convite temporário\n```bash\n# Gerar link\nravi whatsapp group invite group:120363425628305127\n# → https://chat.whatsapp.com/ABC123\n\n# Depois de todos entrarem, revogar\nravi whatsapp group revoke-invite group:120363425628305127\n```\n"
      },
      {
        "path": "skills/cron/SKILL.md",
        "content": "---\nname: cron-manager\ndescription: |\n  Gerencia jobs agendados do sistema Ravi. Use quando o usuário quiser:\n  - Criar, listar ou deletar tarefas agendadas\n  - Configurar cron expressions, intervalos ou horários específicos\n  - Ativar/desativar jobs existentes\n  - Executar jobs manualmente\n---\n\n# Cron Manager\n\nVocê gerencia os jobs agendados do Ravi. Jobs são tarefas que rodam automaticamente em horários ou intervalos específicos.\n\n## Tipos de Schedule\n\n| Tipo | Exemplo | Descrição |\n|------|---------|-----------|\n| `--cron` | `\"0 9 * * *\"` | Cron expression (todo dia 9h) |\n| `--every` | `30m`, `1h`, `2h30m` | Intervalo fixo |\n| `--at` | `2025-02-01T15:00` | Horário único (one-shot) |\n\n## Comandos Disponíveis\n\n### Listar jobs\n```bash\nravi cron list\n```\n\n### Ver detalhes\n```bash\nravi cron show <id>\n```\n\n### Criar job\n\nCom cron expression:\n```bash\nravi cron add \"Relatório Diário\" --cron \"0 9 * * *\" --message \"Gere o relatório diário\"\n```\n\nCom intervalo:\n```bash\nravi cron add \"Check Emails\" --every 30m --message \"Verifique novos emails\"\n```\n\nOne-shot (executa uma vez):\n```bash\nravi cron add \"Lembrete\" --at \"2025-02-01T15:00\" --message \"Lembrar de X\" --delete-after\n```\n\nOpções:\n- `--agent <id>` - Agent que executa\n- `--tz <timezone>` - Fuso horário (ex: America/Sao_Paulo)\n- `--isolated` - Roda em sessão isolada\n- `--delete-after` - Deleta após primeira execução\n- `--description <text>` - Descrição do job\n\n### Ativar/Desativar\n```bash\nravi cron enable <id>\nravi cron disable <id>\n```\n\n### Configurar propriedades\n```bash\nravi cron set <id> <key> <value>\n```\n\nKeys: name, message, cron, every, tz, agent, description, session, delete-after\n\n### Executar manualmente\n```bash\nravi cron run <id>\n```\n\n### Deletar\n```bash\nravi cron rm <id>\n```\n\n## Cron Expression Reference\n\n```\n┌───────────── minuto (0-59)\n│ ┌───────────── hora (0-23)\n│ │ ┌───────────── dia do mês (1-31)\n│ │ │ ┌───────────── mês (1-12)\n│ │ │ │ ┌───────────── dia da semana (0-6, 0=domingo)\n│ │ │ │ │\n* * * * *\n```\n\nExemplos:\n- `0 9 * * *` - Todo dia às 9h\n- `0 9 * * 1-5` - Dias úteis às 9h\n- `*/15 * * * *` - A cada 15 minutos\n- `0 0 1 * *` - Primeiro dia do mês à meia-noite\n- `0 18 * * 5` - Toda sexta às 18h\n\n## Exemplos\n\nRelatório semanal toda segunda:\n```bash\nravi cron add \"Weekly Report\" --cron \"0 9 * * 1\" --message \"Gere relatório semanal\" --tz \"America/Sao_Paulo\"\n```\n\nVerificação a cada 2 horas:\n```bash\nravi cron add \"Health Check\" --every 2h --message \"Verifique status dos sistemas\"\n```\n\nLembrete único:\n```bash\nravi cron add \"Reunião\" --at \"2025-01-30T14:00\" --message \"Lembrar: reunião em 15min\" --delete-after\n```\n"
      },
      {
        "path": "skills/channels/SKILL.md",
        "content": "---\nname: channels-manager\ndescription: |\n  Gerencia canais de comunicação do Ravi via omni. Use quando o usuário quiser:\n  - Ver status das instâncias WhatsApp, Discord, Telegram\n  - Conectar ou desconectar contas\n  - Configurar policies de DM e grupo por instância\n  - Verificar QR code de pareamento\n  - Troubleshoot problemas de conexão\n---\n\n# Channels Manager\n\nCanais são gerenciados pelo omni API server (processo filho do daemon). Cada conta conectada é uma **instância** — a entidade central de configuração do Ravi.\n\n## Instâncias (central config)\n\n### Listar instâncias\n```bash\nravi instances list\nravi instances show <name>\n```\n\n### Conectar nova conta (WhatsApp)\n```bash\nravi instances connect <name>                         # cria instância + conecta (mostra QR)\nravi instances connect vendas --agent vendas-agent\n```\n\n### Configurar instância\n```bash\nravi instances set <name> agent <agent-id>\nravi instances set <name> dmPolicy pairing        # open | pairing | closed\nravi instances set <name> groupPolicy allowlist   # open | allowlist | closed\nravi instances set <name> dmScope per-peer\n```\n\n### Desconectar\n```bash\nravi instances disconnect <name>\n```\n\n### Ver status omni\n```bash\nravi instances status <name>\n```\n\n## Modos de Operação\n\n- `active` - Agent responde automaticamente\n- `sentinel` - Agent observa silenciosamente, responde só quando instruído\n\n## Policies por Instância\n\nCada instância pode ter política independente de acesso:\n\n| Policy | Contexto | Comportamento |\n|--------|----------|---------------|\n| `dmPolicy=open` | DMs | Aceita qualquer DM |\n| `dmPolicy=pairing` | DMs | Só aceita contatos aprovados |\n| `dmPolicy=closed` | DMs | Rejeita todos os DMs |\n| `groupPolicy=open` | Grupos | Aceita qualquer grupo |\n| `groupPolicy=allowlist` | Grupos | Só aceita grupos com rota explícita |\n| `groupPolicy=closed` | Grupos | Rejeita todos os grupos |\n\n```bash\nravi instances set main dmPolicy pairing\nravi instances set vendas groupPolicy allowlist\n```\n\n## Multi-Instância\n\n```bash\nravi instances connect vendas --agent vendas-agent\nravi instances connect suporte --agent suporte-agent\nravi instances set vendas dmPolicy open\nravi instances set suporte groupPolicy allowlist\n```\n\n## Troubleshooting\n\n### WhatsApp não conecta\n```bash\nravi instances status main    # Ver estado da instância\nravi instances connect main   # Reconectar (mostra QR se necessário)\nravi daemon logs              # Ver logs do daemon e omni\n```\n\n### Daemon não inicia\n```bash\nravi daemon logs              # Ver erros de startup\n# Verificar OMNI_DIR em ~/.ravi/.env\n```\n"
      }
    ]
  },
  {
    "name": "ravi-dev",
    "manifest": {
      "name": "ravi-dev",
      "version": "1.0.0",
      "description": "Ravi meta-development skills - architecture docs, prompt system, and internal patterns"
    },
    "files": [
      {
        "path": ".claude-plugin/plugin.json",
        "content": "{\n  \"name\": \"ravi-dev\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Ravi meta-development skills - architecture docs, prompt system, and internal patterns\"\n}\n"
      },
      {
        "path": "skills/architecture/SKILL.md",
        "content": "---\nname: ravi-architecture\ndescription: |\n  Documentacao completa da arquitetura do Ravi. Use quando precisar:\n  - Entender como o sistema funciona end-to-end\n  - Modificar componentes existentes\n  - Adicionar novos subsistemas\n  - Debugar fluxos de mensagem\n  - Onboarding no codebase\n---\n\n# Ravi - Arquitetura do Sistema\n\nRavi é um sistema multi-agent construído sobre o Claude Agent SDK que orquestra conversas em múltiplas plataformas via omni (WhatsApp, Discord, Telegram).\n\n**Repositório:** `/Users/luis/dev/filipelabs/ravi.bot`\n**Runtime:** Bun | **DB:** SQLite | **PubSub:** NATS JetStream | **AI:** Claude SDK\n\n## Fluxo Principal de Mensagens\n\n```\n[WhatsApp/Discord/Telegram]\n    -> omni API (child process)\n    -> NATS JetStream (stream MESSAGE)\n    -> OmniConsumer (subscriber JetStream)\n    -> nats.emit(\"ravi.{sessionKey}.prompt\")\n    -> RaviBot (Claude SDK query)\n    -> nats.emit(\"ravi.{sessionKey}.response\")\n    -> Gateway\n    -> OmniSender (HTTP POST /api/v2/messages/send)\n    -> omni API\n    -> [WhatsApp/Discord/Telegram]\n```\n\n## Componentes Core\n\n### daemon.ts - Ponto de Entrada\nOrquestra startup de todos os subsistemas:\n1. Carrega env de `~/.ravi/.env`\n2. Inicia nats-server com JetStream (`local/server.ts`)\n3. Inicia omni API server (`local/omni.ts`)\n4. Inicia RaviBot (Claude SDK)\n5. Inicia OmniConsumer + Gateway\n6. Inicia HeartbeatRunner, CronRunner, OutboundRunner, TriggerRunner\n\nShutdown tem timeout global de 15s (force-exit se travar).\n\n### local/server.ts - nats-server\nSpawna nats-server com JetStream habilitado (`-js`). Armazena em `~/.ravi/jetstream/`.\nInclui recovery automático: se startup falhar (WAL corrompido), limpa storage e reinicia.\n\n### local/omni.ts - omni API\nSpawna omni API como child process (bun). Gerencia:\n- Build do bundle na primeira vez\n- Migrations de banco\n- API key bootstrap (`~/.ravi/omni-api-key`)\n- Healthcheck via HTTP GET /health\n\n### omni/consumer.ts - Inbound\nSubscriber de dois streams JetStream do omni:\n- `MESSAGE` (filter: `message.received.>`) → prompts de agente\n- `INSTANCE` (filter: `instance.>`) → QR codes, conexão\n\nComportamento:\n- `start()` aguarda consumers ficarem prontos (timeout 60s, continua em background)\n- `msg.ack()` apenas após handler suceder; `msg.nak()` em erro (retry automático)\n- Auto-reconnect em erro de consumo (loop com retry 2s)\n- Config subscription com auto-reconnect para `ravi.config.changed`\n\n### omni/sender.ts - Outbound\nHTTP client para omni REST API (`@omni/sdk`). Métodos:\n- `send(instanceId, to, text)` — texto\n- `sendTyping(instanceId, to, active)` — indicador de digitação\n- `sendReaction(instanceId, to, messageId, emoji)` — reação\n- `sendMedia(instanceId, to, path, type, filename, caption)` — mídia\n\nRetry com backoff exponencial (3x, 1s/2s/3s). Só retenta TypeErrors (rede) e 5xx.\n\n### gateway.ts - Orquestrador Interno\nSubscriptions internas do ravi (não gerencia canais):\n- `ravi.*.response` → OmniSender.send()\n- `ravi.outbound.deliver` → OmniSender.send()\n- `ravi.*.claude` → typing heartbeat → OmniSender.sendTyping()\n- `ravi.outbound.reaction` → OmniSender.sendReaction()\n- `ravi.config.changed` → sync REBAC\n\n### bot.ts - Core do Bot\nProcessa prompts usando Claude Agent SDK.\n\n**Fluxo:**\n1. Subscribe em `ravi.*.prompt`\n2. Resolve agent config pela session key\n3. Debounce se configurado\n4. Cria/resume SDK session\n5. Streama resposta → emite responses parciais\n6. Gerencia interrupts (msg nova durante processamento)\n\n**Abort control:**\n- Cada sessão tem AbortController\n- Novo prompt aborta subprocess anterior\n- Daemon stop aborta TODOS os controllers\n- Watchdog de 5min detecta sessões travadas\n\n### router/ - Sistema de Roteamento\n\n**Resolução de rota (prioridade):**\n1. Rota `thread:ID` — mais específica (thread dentro de grupo)\n2. Rota `group:ID` ou padrão de telefone\n3. Mapeamento `instance.agent` (tabela `instances`)\n4. Agent default\n\n**Policy resolution (por mensagem):**\n```\nroute.policy → instance.dmPolicy/groupPolicy → legacy account.* settings → \"open\"\n```\n\n**Session keys:**\n```\nagent:{agentId}:{scope}:{peerId}\nagent:main:main                          # Todas DMs (scope=main)\nagent:main:dm:5511999                    # Por contato\nagent:main:whatsapp:group:123456         # Grupo\nagent:main:whatsapp:main:group:123456:thread:abc  # Thread\nagent:main:outbound:queueId:phone        # Outbound\n```\n\n**Instâncias (tabela `instances`):**\nEntidade central que une canal + agent + policies. Substitui namespace `account.*` de settings.\n```typescript\ninterface InstanceConfig {\n  name: string;        // nome da conta omni (ex: \"main\", \"vendas\")\n  instanceId?: string; // UUID do omni\n  channel: string;     // \"whatsapp\" | \"matrix\" | ...\n  agent?: string;      // agent padrão desta instância\n  dmPolicy: \"open\" | \"pairing\" | \"closed\";\n  groupPolicy: \"open\" | \"allowlist\" | \"closed\";\n  dmScope?: DmScope;\n}\n```\n\n**Arquivos:**\n- `router/resolver.ts` - Resolve rota → session key (matchRoute, findRoute)\n- `router/session-key.ts` - Constrói/parseia session keys\n- `router/sessions.ts` - CRUD de sessões (SQLite)\n- `router/config.ts` - Carrega RouterConfig (agents + routes + instances)\n- `router/router-db.ts` - Camada de banco (CRUD agents, routes, instances, settings)\n\n## Subsistemas de Automação\n\n### Outbound (`outbound/`)\nCampanhas de mensagens proativas com processamento round-robin.\n\n**Fluxo:**\n1. Runner pega próxima queue do DB\n2. Arma timer para `nextRunAt`\n3. Processa entries por prioridade:\n   - Response entries (contato respondeu)\n   - Follow-up entries (sem resposta, precisa follow-up)\n   - Initial outreach (entries pendentes)\n4. Manda prompt para agent com contexto da campanha\n\n**Qualificação:** cold → warm → interested → qualified/rejected\n\n### Triggers (`triggers/`)\nAutomação event-driven disparada por eventos do sistema.\n\n**Fluxo:**\n1. Runner subscribe em topics configurados\n2. Evento dispara → busca triggers ativos com match\n3. Emite prompt para sessão target do trigger\n4. Respeita cooldown entre disparos\n\n### Cron (`cron/`)\nJobs agendados com suporte a múltiplos formatos.\n\n**Schedules:** cron expression | interval (\"30m\") | daily (\"09:00\") | at (one-time)\n\n**Fluxo:** Timer → job due → emite prompt → calcula próximo run\n\n### Heartbeat (`heartbeat/`)\nCheck-ins periódicos de agents dentro de horários ativos.\n\n**Fluxo:**\n1. Checa agents com heartbeat enabled\n2. Para cada sessão, verifica se está due\n3. Checa active hours (timezone-aware)\n4. Envia prompt de status check\n5. `HEARTBEAT_OK` = silencioso, qualquer outro texto = envia pro canal\n\n### Session Messaging (`cli/commands/sessions.ts`)\nMensagens entre sessões (inter-session communication).\n\n**Comandos:** `sessions send` | `sessions inform` | `sessions execute` | `sessions ask` | `sessions answer`\n\n## Sistema de Plugins\n\n**Duas fontes:**\n1. **Internos** - Embutidos no build, extraídos para `~/.cache/ravi/plugins/`\n2. **Usuário** - Customizados em `~/ravi/plugins/`\n\n**Build time:** `gen-plugins.ts` escaneia `src/plugins/internal/` e gera `internal-registry.ts`\n**Runtime:** `discoverPlugins()` extrai internos + escaneia user dir → passa para SDK\n\n## Sistema de Hooks\n\n### PreToolUse (bash/hook.ts)\nIntercepta chamadas Bash e valida permissões via REBAC.\nCheca `agentCan(id, \"execute\", \"executable\", exec)` pra cada executável parsed.\n\n### PreCompact (hooks/pre-compact.ts)\nExtrai memórias antes do SDK compactar contexto.\nLê `COMPACT_INSTRUCTIONS.md` do agent, roda modelo barato em background, atualiza `MEMORY.md`.\n\n## Infraestrutura CLI\n\n### Decorators\n```typescript\n@Group({ name: \"agents\" })\nclass AgentCommands {\n  @Command({ name: \"list\" })\n  list() { ... }\n\n  @Command({ name: \"create\" })\n  create(@Arg(\"id\") id: string) { ... }\n}\n```\n\n### Contexto (AsyncLocalStorage)\n```typescript\nrunWithContext({ sessionKey, agentId, source }, async () => {\n  const ctx = getContext();\n});\n```\n\n## Storage\n\n```\n~/ravi/ravi.db          - SQLite: agents, routes, sessions, contacts, settings\n~/.ravi/.env            - API keys e env vars\n~/.ravi/omni-api-key    - API key para omni (auto-gerada)\n~/.ravi/jetstream/      - JetStream storage (nats-server)\n~/.ravi/logs/           - Logs do daemon\n~/ravi/{agent-id}/      - Diretórios dos agents (CLAUDE.md, MEMORY.md)\n~/.cache/ravi/plugins/  - Plugins internos extraídos\n~/.claude/sessions/     - SDK session files (JSONL)\n```\n\n## Env Vars Importantes\n\n```bash\nOMNI_DIR=/path/to/omni-v2      # obrigatório para canal WhatsApp/Discord/Telegram\nOMNI_API_PORT=8882              # default\nDATABASE_URL=postgresql://...   # banco do omni\nNATS_PORT=4222                  # default\n```\n\n## Padrões Importantes\n\n1. **JetStream pull consumers** - Mensagens inbound via durable consumers (ACK explícito)\n2. **PubSub via NATS** - Tudo comunica via topics internos\n3. **Ghost detection** - `_emitId` + `_instanceId` previne duplicatas\n4. **Abort control** - AbortController por sessão, cleanup no stop\n5. **Debouncing** - Agrupa msgs rápidas por window configurável\n6. **Outbound suppression** - Msgs de contatos outbound não geram prompt duplicado\n7. **Silent token** - `@@SILENT@@` suprime emissão pro canal\n8. **Session resumption** - SDK sessions persistem entre mensagens\n"
      },
      {
        "path": "skills/prompt-builder/SKILL.md",
        "content": "---\nname: prompt-builder\ndescription: |\n  Documenta o sistema de construcao de prompts do Ravi. Use quando precisar:\n  - Entender como system prompts sao montados\n  - Adicionar novas secoes ao prompt\n  - Modificar formatacao por canal\n  - Entender injecao de contexto (grupo, reactions, runtime)\n  - Criar novas regras de output por plataforma\n---\n\n# Prompt Builder - Sistema de Injecao de Contexto\n\nO prompt builder constroi o system prompt appendix que e injetado em cada chamada do Claude SDK.\nEle adapta o comportamento do agent baseado no canal, grupo, e contexto da mensagem.\n\n**Arquivo:** `src/prompt-builder.ts`\n\n## Como Funciona\n\n```typescript\n// bot.ts - na hora de processar prompt\nconst systemPromptAppend = buildSystemPrompt(agent.id, prompt.context);\n\nquery({\n  prompt: prompt.prompt,\n  options: {\n    systemPrompt: {\n      type: \"preset\",\n      preset: \"claude_code\",\n      append: systemPromptAppend,  // <-- injetado aqui\n    },\n  },\n});\n```\n\nO SDK usa o preset `claude_code` como base e appenda nossas secoes.\n\n## Estrutura do Builder\n\n```typescript\nclass PromptBuilder {\n  section(title: string, content: string): this;\n  build(): string;  // Retorna \"## Title\\n\\nContent\" para cada secao\n}\n```\n\n## Secoes Injetadas\n\nA funcao `buildSystemPrompt(agentId, ctx)` monta as secoes:\n\n### 1. Identidade (sempre)\n```\n## Identidade\nVoce e Ravi.\n```\n\n### 2. System Commands (sempre)\nProtocolo de comandos internos:\n- `[System] Inform: <info>` - Avalie a info e decida: silêncio (@@SILENT@@), resposta breve, ou ação com tools\n- `[System] Execute: <task>` - Execute usando tools\n- `[System] Ask: [from: <session>] <question>` - Pergunta cross-session\n- `[System] Answer: [from: <session>] <response>` - Resposta cross-session\n- *(relay não tem prefixo — chega como mensagem normal)*\n\n### 3. Runtime (quando tem contexto de canal)\n```\nRuntime: agent=main | channel=WhatsApp | capabilities=polls,reactions\n```\n\n### 4. Output Formatting (quando tem contexto de canal)\nFormatacao adaptada por plataforma:\n\n**WhatsApp:**\n- Listas com emojis numerados (1, 2, 3)\n- Icones visuais para hierarquia\n- Status com check/x\n- Sem tabelas markdown\n- Conciso (telas mobile)\n\n**Matrix:**\n- Markdown rico (tabelas, negrito, codigo)\n\n**TUI:**\n- ASCII tables (| - +)\n\n### 5. Reactions (quando tem contexto de canal)\nInstrucoes de quando usar emoji reactions vs texto:\n- Prefira emoji sobre \"ok\", \"entendi\", \"beleza\"\n- O `[mid:ID]` no header identifica a mensagem\n- Nao reaja E responda ao mesmo tempo\n\n### 6. Contexto de Grupo (quando isGroup=true)\n```\nVoce esta respondendo no grupo \"Familia\".\nMembros: Joao, Maria, Luis.\nSeja seletivo: responda so quando mencionado ou claramente util.\nSe nao precisa responder: @@SILENT@@\n```\n\n## Fluxo de Contexto\n\n```\nWhatsApp msg recebida\n    -> Channel normaliza -> InboundMessage\n    -> Gateway extrai MessageContext:\n       { channelId, channelName, senderId, isGroup, groupName, groupMembers, ... }\n    -> Emite para bot com context\n    -> bot.ts chama buildSystemPrompt(agentId, context)\n    -> Prompt appendix montado com secoes relevantes\n    -> Passado para Claude SDK\n```\n\n## MessageContext (origem)\n\n```typescript\ninterface MessageContext {\n  channelId: string;       // \"whatsapp\"\n  channelName: string;     // \"WhatsApp\"\n  accountId: string;       // \"default\"\n  chatId: string;          // \"5511999999999\"\n  messageId: string;       // ID da msg\n  senderId: string;        // Quem mandou\n  senderName?: string;     // Nome do remetente\n  senderPhone?: string;    // Telefone\n  isGroup: boolean;\n  groupName?: string;\n  groupId?: string;\n  groupMembers?: string[];\n  timestamp: number;\n}\n```\n\n## ChannelContext (persistido)\n\nMetadados estaveis que sao salvos na sessao para reuso:\n\n```typescript\ninterface ChannelContext {\n  channelId: string;\n  channelName: string;\n  isGroup: boolean;\n  groupName?: string;\n  groupId?: string;\n  groupMembers?: string[];\n}\n```\n\nSalvo em `sessions.last_context` como JSON. Usado pelo cross-send para reconstruir contexto.\n\n## Silent Token\n\n```typescript\nexport const SILENT_TOKEN = \"@@SILENT@@\";\n```\n\nQuando o agent responde com este token:\n- Gateway NAO envia para o canal\n- Bot emite evento `{ type: \"silent\" }` para parar typing\n- Usado em grupos quando nao precisa responder\n\n## Como Adicionar uma Nova Secao\n\n1. Crie a funcao no `prompt-builder.ts`:\n```typescript\nfunction minhaSecao(ctx: ChannelContext): string {\n  return `Instrucoes especificas aqui...`;\n}\n```\n\n2. Adicione ao builder em `buildSystemPrompt()`:\n```typescript\nbuilder.section(\"Minha Secao\", minhaSecao(ctx));\n```\n\n3. Rebuild e reinicie o daemon.\n\n## Como Adicionar Formatacao para Novo Canal\n\n1. Adicione um case em `outputFormattingText()`:\n```typescript\nif (channelName === \"MeuCanal\") {\n  return `Regras de formatacao para MeuCanal...`;\n}\n```\n\n2. O channelName vem do `channelType` do OmniConsumer (ex: `\"whatsapp-baileys\"`, `\"discord\"`, `\"telegram\"`).\n\n## Outbound System Context\n\nO sistema de outbound injeta contexto adicional via `prompt._outboundSystemContext`:\n```typescript\nif (prompt._outboundSystemContext) {\n  systemPromptAppend += \"\\n\\n\" + prompt._outboundSystemContext;\n}\n```\n\nIsso inclui:\n- Instrucoes da queue\n- Tools disponiveis (outbound_send, outbound_qualify, etc)\n- Workflow de qualificacao\n- Metadata da entry (ID, round, qualification)\n"
      }
    ]
  }
];

/** Get internal plugin by name */
export function getInternalPlugin(name: string): InternalPlugin | undefined {
  return INTERNAL_PLUGINS.find(p => p.name === name);
}

/** Get all internal plugin names */
export function getInternalPluginNames(): string[] {
  return INTERNAL_PLUGINS.map(p => p.name);
}
